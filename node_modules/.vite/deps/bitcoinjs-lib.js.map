{
  "version": 3,
  "sources": ["../../bech32/dist/index.js", "../../bitcoinjs-lib/src/esm/address.js", "../../bitcoinjs-lib/src/esm/networks.js", "../../bitcoinjs-lib/src/esm/payments/index.js", "../../bitcoinjs-lib/src/esm/script.js", "../../bitcoinjs-lib/src/esm/bip66.js", "../../bitcoinjs-lib/src/esm/ops.js", "../../uint8array-tools/src/mjs/browser.js", "../../bitcoinjs-lib/src/esm/push_data.js", "../../bitcoinjs-lib/src/esm/script_number.js", "../../bitcoinjs-lib/src/esm/script_signature.js", "../../valibot/dist/index.js", "../../bitcoinjs-lib/src/esm/types.js", "../../bitcoinjs-lib/src/esm/payments/lazy.js", "../../bitcoinjs-lib/src/esm/payments/embed.js", "../../bitcoinjs-lib/src/esm/payments/p2ms.js", "../../bitcoinjs-lib/src/esm/payments/p2pk.js", "../../bitcoinjs-lib/src/esm/crypto.js", "../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/legacy.ts", "../../@noble/hashes/src/ripemd160.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/sha2.ts", "../../@noble/hashes/src/sha256.ts", "../../base-x/src/esm/index.js", "../../bs58/src/esm/index.js", "../../bs58check/src/esm/base.js", "../../bs58check/src/esm/index.js", "../../bitcoinjs-lib/src/esm/payments/p2pkh.js", "../../bitcoinjs-lib/src/esm/payments/p2sh.js", "../../bitcoinjs-lib/src/esm/payments/p2wpkh.js", "../../bitcoinjs-lib/src/esm/payments/p2wsh.js", "../../bitcoinjs-lib/src/esm/ecc_lib.js", "../../varuint-bitcoin/src/esm/index.js", "../../varuint-bitcoin/node_modules/uint8array-tools/src/mjs/browser.js", "../../bitcoinjs-lib/src/esm/bufferutils.js", "../../bitcoinjs-lib/src/esm/payments/bip341.js", "../../bitcoinjs-lib/src/esm/payments/p2tr.js", "../../bitcoinjs-lib/src/esm/merkle.js", "../../bitcoinjs-lib/src/esm/transaction.js", "../../bitcoinjs-lib/src/esm/block.js", "../../bip174/src/esm/lib/converter/index.js", "../../bip174/src/esm/lib/typeFields.js", "../../bip174/src/esm/lib/converter/global/globalXpub.js", "../../bip174/src/esm/lib/converter/global/unsignedTx.js", "../../bip174/src/esm/lib/converter/input/finalScriptSig.js", "../../bip174/src/esm/lib/converter/input/finalScriptWitness.js", "../../bip174/src/esm/lib/converter/input/nonWitnessUtxo.js", "../../bip174/src/esm/lib/converter/input/partialSig.js", "../../bip174/src/esm/lib/converter/input/porCommitment.js", "../../bip174/src/esm/lib/converter/input/sighashType.js", "../../bip174/src/esm/lib/converter/input/tapKeySig.js", "../../bip174/src/esm/lib/converter/input/tapLeafScript.js", "../../bip174/src/esm/lib/converter/input/tapMerkleRoot.js", "../../bip174/src/esm/lib/converter/input/tapScriptSig.js", "../../bip174/src/esm/lib/converter/input/witnessUtxo.js", "../../bip174/src/esm/lib/converter/output/tapTree.js", "../../bip174/src/esm/lib/converter/shared/bip32Derivation.js", "../../bip174/src/esm/lib/converter/shared/checkPubkey.js", "../../bip174/src/esm/lib/converter/shared/redeemScript.js", "../../bip174/src/esm/lib/converter/shared/tapBip32Derivation.js", "../../bip174/src/esm/lib/converter/shared/tapInternalKey.js", "../../bip174/src/esm/lib/converter/shared/witnessScript.js", "../../bip174/src/esm/lib/converter/tools.js", "../../bip174/src/esm/lib/parser/fromBuffer.js", "../../bip174/src/esm/lib/parser/toBuffer.js", "../../bip174/src/esm/lib/combiner/index.js", "../../bip174/src/esm/lib/utils.js", "../../bip174/src/esm/lib/psbt.js", "../../bitcoinjs-lib/src/esm/psbt/psbtutils.js", "../../bitcoinjs-lib/src/esm/psbt/bip371.js", "../../bitcoinjs-lib/src/esm/psbt.js"],
  "sourcesContent": ["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n", "import * as networks from './networks.js';\nimport * as payments from './payments/index.js';\nimport * as bscript from './script.js';\nimport { Hash160bitSchema, UInt8Schema } from './types.js';\nimport { bech32, bech32m } from 'bech32';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nconst WARNING_STATES = [false, false];\n/**\n * Converts an output buffer to a future segwit address.\n * @param output - The output buffer.\n * @param network - The network object.\n * @returns The future segwit address.\n * @throws {TypeError} If the program length or version is invalid for segwit address.\n */\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  if (WARNING_STATES[0] === false) {\n    console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n    WARNING_STATES[0] = true;\n  }\n  return toBech32(data, version, network.bech32);\n}\n/**\n * Decodes a base58check encoded Bitcoin address and returns the version and hash.\n *\n * @param address - The base58check encoded Bitcoin address to decode.\n * @returns An object containing the version and hash of the decoded address.\n * @throws {TypeError} If the address is too short or too long.\n */\nexport function fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = tools.readUInt8(payload, 0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\n/**\n * Converts a Bech32 or Bech32m encoded address to its corresponding data representation.\n * @param address - The Bech32 or Bech32m encoded address.\n * @returns An object containing the version, prefix, and data of the address.\n * @throws {TypeError} If the address uses the wrong encoding.\n */\nexport function fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Uint8Array.from(data),\n  };\n}\n/**\n * Converts a hash to a Base58Check-encoded string.\n * @param hash - The hash to be encoded.\n * @param version - The version byte to be prepended to the encoded string.\n * @returns The Base58Check-encoded string.\n */\nexport function toBase58Check(hash, version) {\n  v.parse(v.tuple([Hash160bitSchema, UInt8Schema]), [hash, version]);\n  const payload = new Uint8Array(21);\n  tools.writeUInt8(payload, 0, version);\n  payload.set(hash, 1);\n  return bs58check.encode(payload);\n}\n/**\n * Converts a buffer to a Bech32 or Bech32m encoded string.\n * @param data - The buffer to be encoded.\n * @param version - The version number to be used in the encoding.\n * @param prefix - The prefix string to be used in the encoding.\n * @returns The Bech32 or Bech32m encoded string.\n */\nexport function toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32.encode(prefix, words)\n    : bech32m.encode(prefix, words);\n}\n/**\n * Converts an output script to a Bitcoin address.\n * @param output - The output script as a Buffer.\n * @param network - The Bitcoin network (optional).\n * @returns The Bitcoin address corresponding to the output script.\n * @throws If the output script has no matching address.\n */\nexport function fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n/**\n * Converts a Bitcoin address to its corresponding output script.\n * @param address - The Bitcoin address to convert.\n * @param network - The Bitcoin network to use. Defaults to the Bitcoin network.\n * @returns The corresponding output script as a Buffer.\n * @throws If the address has an invalid prefix or no matching script.\n */\nexport function toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        if (WARNING_STATES[1] === false) {\n          console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n          WARNING_STATES[1] = true;\n        }\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\n", "/**\n * Represents the Bitcoin network configuration.\n */\nexport const bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexport const regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexport const testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n", "import { p2data as embed } from './embed.js';\nimport { p2ms } from './p2ms.js';\nimport { p2pk } from './p2pk.js';\nimport { p2pkh } from './p2pkh.js';\nimport { p2sh } from './p2sh.js';\nimport { p2wpkh } from './p2wpkh.js';\nimport { p2wsh } from './p2wsh.js';\nimport { p2tr } from './p2tr.js';\nexport { embed, p2ms, p2pk, p2pkh, p2sh, p2wpkh, p2wsh, p2tr };\n// TODO\n// witness commitment\n", "/**\n * Script tools module for working with Bitcoin scripts.\n * Provides utilities such as decompiling, compiling, converting to/from ASM, stack manipulation,\n * and script validation functions.\n *\n * @packageDocumentation\n */\nimport * as bip66 from './bip66.js';\nimport { OPS } from './ops.js';\nimport * as pushdata from './push_data.js';\nimport * as scriptNumber from './script_number.js';\nimport * as scriptSignature from './script_signature.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\n/** Base opcode for OP_INT values. */\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nexport { OPS };\n/** Validation schema for a Bitcoin script stack. */\nconst StackSchema = v.array(v.union([v.instance(Uint8Array), v.number()]));\n/**\n * Determines if a value corresponds to an OP_INT opcode.\n *\n * @param value - The opcode to check.\n * @returns True if the value is an OP_INT, false otherwise.\n */\nfunction isOPInt(value) {\n  return (\n    v.is(v.number(), value) &&\n    (value === OPS.OP_0 ||\n      (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n      value === OPS.OP_1NEGATE)\n  );\n}\n/**\n * Checks if a script chunk is push-only (contains only data or OP_INT opcodes).\n *\n * @param value - The chunk to check.\n * @returns True if the chunk is push-only, false otherwise.\n */\nfunction isPushOnlyChunk(value) {\n  return v.is(types.BufferSchema, value) || isOPInt(value);\n}\n/**\n * Determines if a stack consists of only push operations.\n *\n * @param value - The stack to check.\n * @returns True if all elements in the stack are push-only, false otherwise.\n */\nexport function isPushOnly(value) {\n  return v.is(v.pipe(v.any(), v.everyItem(isPushOnlyChunk)), value);\n}\n/**\n * Counts the number of non-push-only opcodes in a stack.\n *\n * @param value - The stack to analyze.\n * @returns The count of non-push-only opcodes.\n */\nexport function countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\n/**\n * Converts a minimal script buffer to its corresponding opcode, if applicable.\n *\n * @param buffer - The buffer to check.\n * @returns The corresponding opcode or undefined if not minimal.\n */\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\n/**\n * Determines if a buffer or stack is a Uint8Array.\n *\n * @param buf - The buffer or stack to check.\n * @returns True if the input is a Uint8Array, false otherwise.\n */\nfunction chunksIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\n/**\n * Determines if a buffer or stack is a valid stack.\n *\n * @param buf - The buffer or stack to check.\n * @returns True if the input is a stack, false otherwise.\n */\nfunction chunksIsArray(buf) {\n  return v.is(StackSchema, buf);\n}\n/**\n * Determines if a single chunk is a Uint8Array.\n *\n * @param buf - The chunk to check.\n * @returns True if the chunk is a Uint8Array, false otherwise.\n */\nfunction singleChunkIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\n/**\n * Compiles an array of script chunks into a Uint8Array.\n *\n * @param chunks - The chunks to compile.\n * @returns The compiled script as a Uint8Array.\n * @throws Error if compilation fails.\n */\nexport function compile(chunks) {\n  if (chunksIsBuffer(chunks)) return chunks;\n  v.parse(StackSchema, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    return accum + 1;\n  }, 0);\n  const buffer = new Uint8Array(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        tools.writeUInt8(buffer, offset, opcode);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      buffer.set(chunk, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      tools.writeUInt8(buffer, offset, chunk);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\n/**\n * Decompiles a script buffer into an array of chunks.\n *\n * @param buffer - The script buffer to decompile.\n * @returns The decompiled chunks or null if decompilation fails.\n */\nexport function decompile(buffer) {\n  if (chunksIsArray(buffer)) return buffer;\n  v.parse(types.BufferSchema, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nexport function toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return tools.toHex(chunk);\n        chunk = op;\n      }\n      // opcode!\n      return OPS[chunk];\n    })\n    .join(' ');\n}\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nexport function fromASM(asm) {\n  v.parse(v.string(), asm);\n  // Compile the ASM string into a Uint8Array\n  return compile(\n    asm.split(' ').map(chunk => {\n      // Check if the chunk is an opcode\n      if (isNaN(Number(chunk)) && chunk in OPS) {\n        return OPS[chunk];\n      }\n      // Validate if the chunk is a hexadecimal string\n      v.parse(types.HexSchema, chunk);\n      // Convert the chunk to Uint8Array data\n      return tools.fromHex(chunk);\n    }),\n  );\n}\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nexport function toStack(chunks) {\n  chunks = decompile(chunks);\n  v.parse(v.custom(isPushOnly), chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === OPS.OP_0) return new Uint8Array(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\n/**\n * Checks if the provided buffer is a canonical public key.\n *\n * @param buffer - The buffer to check, expected to be a Uint8Array.\n * @returns A boolean indicating whether the buffer is a canonical public key.\n */\nexport function isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\n/**\n * Checks if the provided hash type is defined.\n *\n * A hash type is considered defined if its modified value (after masking with ~0x80)\n * is greater than 0x00 and less than 0x04.\n *\n * @param hashType - The hash type to check.\n * @returns True if the hash type is defined, false otherwise.\n */\nexport function isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\n/**\n * Checks if the provided buffer is a canonical script signature.\n *\n * A canonical script signature is a valid DER-encoded signature followed by a valid hash type byte.\n *\n * @param buffer - The buffer to check.\n * @returns `true` if the buffer is a canonical script signature, `false` otherwise.\n */\nexport function isCanonicalScriptSignature(buffer) {\n  if (!(buffer instanceof Uint8Array)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexport const number = scriptNumber;\nexport const signature = scriptSignature;\n", "// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\n/**\n * Checks if the given buffer is a valid BIP66-encoded signature.\n *\n * @param buffer - The buffer to check.\n * @returns A boolean indicating whether the buffer is a valid BIP66-encoded signature.\n */\nexport function check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\n/**\n * Decodes a DER-encoded signature buffer and returns the R and S values.\n * @param buffer - The DER-encoded signature buffer.\n * @returns An object containing the R and S values.\n * @throws {Error} If the DER sequence length is too short, too long, or invalid.\n * @throws {Error} If the R or S length is zero or invalid.\n * @throws {Error} If the R or S value is negative or excessively padded.\n */\nexport function decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nexport function encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = new Uint8Array(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  signature.set(r, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  signature.set(s, 6 + lenR);\n  return signature;\n}\n", "// Define OPS enum\nvar OPS;\n(function (OPS) {\n  OPS[(OPS['OP_FALSE'] = 0)] = 'OP_FALSE';\n  OPS[(OPS['OP_0'] = 0)] = 'OP_0';\n  OPS[(OPS['OP_PUSHDATA1'] = 76)] = 'OP_PUSHDATA1';\n  OPS[(OPS['OP_PUSHDATA2'] = 77)] = 'OP_PUSHDATA2';\n  OPS[(OPS['OP_PUSHDATA4'] = 78)] = 'OP_PUSHDATA4';\n  OPS[(OPS['OP_1NEGATE'] = 79)] = 'OP_1NEGATE';\n  OPS[(OPS['OP_RESERVED'] = 80)] = 'OP_RESERVED';\n  OPS[(OPS['OP_TRUE'] = 81)] = 'OP_TRUE';\n  OPS[(OPS['OP_1'] = 81)] = 'OP_1';\n  OPS[(OPS['OP_2'] = 82)] = 'OP_2';\n  OPS[(OPS['OP_3'] = 83)] = 'OP_3';\n  OPS[(OPS['OP_4'] = 84)] = 'OP_4';\n  OPS[(OPS['OP_5'] = 85)] = 'OP_5';\n  OPS[(OPS['OP_6'] = 86)] = 'OP_6';\n  OPS[(OPS['OP_7'] = 87)] = 'OP_7';\n  OPS[(OPS['OP_8'] = 88)] = 'OP_8';\n  OPS[(OPS['OP_9'] = 89)] = 'OP_9';\n  OPS[(OPS['OP_10'] = 90)] = 'OP_10';\n  OPS[(OPS['OP_11'] = 91)] = 'OP_11';\n  OPS[(OPS['OP_12'] = 92)] = 'OP_12';\n  OPS[(OPS['OP_13'] = 93)] = 'OP_13';\n  OPS[(OPS['OP_14'] = 94)] = 'OP_14';\n  OPS[(OPS['OP_15'] = 95)] = 'OP_15';\n  OPS[(OPS['OP_16'] = 96)] = 'OP_16';\n  OPS[(OPS['OP_NOP'] = 97)] = 'OP_NOP';\n  OPS[(OPS['OP_VER'] = 98)] = 'OP_VER';\n  OPS[(OPS['OP_IF'] = 99)] = 'OP_IF';\n  OPS[(OPS['OP_NOTIF'] = 100)] = 'OP_NOTIF';\n  OPS[(OPS['OP_VERIF'] = 101)] = 'OP_VERIF';\n  OPS[(OPS['OP_VERNOTIF'] = 102)] = 'OP_VERNOTIF';\n  OPS[(OPS['OP_ELSE'] = 103)] = 'OP_ELSE';\n  OPS[(OPS['OP_ENDIF'] = 104)] = 'OP_ENDIF';\n  OPS[(OPS['OP_VERIFY'] = 105)] = 'OP_VERIFY';\n  OPS[(OPS['OP_RETURN'] = 106)] = 'OP_RETURN';\n  OPS[(OPS['OP_TOALTSTACK'] = 107)] = 'OP_TOALTSTACK';\n  OPS[(OPS['OP_FROMALTSTACK'] = 108)] = 'OP_FROMALTSTACK';\n  OPS[(OPS['OP_2DROP'] = 109)] = 'OP_2DROP';\n  OPS[(OPS['OP_2DUP'] = 110)] = 'OP_2DUP';\n  OPS[(OPS['OP_3DUP'] = 111)] = 'OP_3DUP';\n  OPS[(OPS['OP_2OVER'] = 112)] = 'OP_2OVER';\n  OPS[(OPS['OP_2ROT'] = 113)] = 'OP_2ROT';\n  OPS[(OPS['OP_2SWAP'] = 114)] = 'OP_2SWAP';\n  OPS[(OPS['OP_IFDUP'] = 115)] = 'OP_IFDUP';\n  OPS[(OPS['OP_DEPTH'] = 116)] = 'OP_DEPTH';\n  OPS[(OPS['OP_DROP'] = 117)] = 'OP_DROP';\n  OPS[(OPS['OP_DUP'] = 118)] = 'OP_DUP';\n  OPS[(OPS['OP_NIP'] = 119)] = 'OP_NIP';\n  OPS[(OPS['OP_OVER'] = 120)] = 'OP_OVER';\n  OPS[(OPS['OP_PICK'] = 121)] = 'OP_PICK';\n  OPS[(OPS['OP_ROLL'] = 122)] = 'OP_ROLL';\n  OPS[(OPS['OP_ROT'] = 123)] = 'OP_ROT';\n  OPS[(OPS['OP_SWAP'] = 124)] = 'OP_SWAP';\n  OPS[(OPS['OP_TUCK'] = 125)] = 'OP_TUCK';\n  OPS[(OPS['OP_CAT'] = 126)] = 'OP_CAT';\n  OPS[(OPS['OP_SUBSTR'] = 127)] = 'OP_SUBSTR';\n  OPS[(OPS['OP_LEFT'] = 128)] = 'OP_LEFT';\n  OPS[(OPS['OP_RIGHT'] = 129)] = 'OP_RIGHT';\n  OPS[(OPS['OP_SIZE'] = 130)] = 'OP_SIZE';\n  OPS[(OPS['OP_INVERT'] = 131)] = 'OP_INVERT';\n  OPS[(OPS['OP_AND'] = 132)] = 'OP_AND';\n  OPS[(OPS['OP_OR'] = 133)] = 'OP_OR';\n  OPS[(OPS['OP_XOR'] = 134)] = 'OP_XOR';\n  OPS[(OPS['OP_EQUAL'] = 135)] = 'OP_EQUAL';\n  OPS[(OPS['OP_EQUALVERIFY'] = 136)] = 'OP_EQUALVERIFY';\n  OPS[(OPS['OP_RESERVED1'] = 137)] = 'OP_RESERVED1';\n  OPS[(OPS['OP_RESERVED2'] = 138)] = 'OP_RESERVED2';\n  OPS[(OPS['OP_1ADD'] = 139)] = 'OP_1ADD';\n  OPS[(OPS['OP_1SUB'] = 140)] = 'OP_1SUB';\n  OPS[(OPS['OP_2MUL'] = 141)] = 'OP_2MUL';\n  OPS[(OPS['OP_2DIV'] = 142)] = 'OP_2DIV';\n  OPS[(OPS['OP_NEGATE'] = 143)] = 'OP_NEGATE';\n  OPS[(OPS['OP_ABS'] = 144)] = 'OP_ABS';\n  OPS[(OPS['OP_NOT'] = 145)] = 'OP_NOT';\n  OPS[(OPS['OP_0NOTEQUAL'] = 146)] = 'OP_0NOTEQUAL';\n  OPS[(OPS['OP_ADD'] = 147)] = 'OP_ADD';\n  OPS[(OPS['OP_SUB'] = 148)] = 'OP_SUB';\n  OPS[(OPS['OP_MUL'] = 149)] = 'OP_MUL';\n  OPS[(OPS['OP_DIV'] = 150)] = 'OP_DIV';\n  OPS[(OPS['OP_MOD'] = 151)] = 'OP_MOD';\n  OPS[(OPS['OP_LSHIFT'] = 152)] = 'OP_LSHIFT';\n  OPS[(OPS['OP_RSHIFT'] = 153)] = 'OP_RSHIFT';\n  OPS[(OPS['OP_BOOLAND'] = 154)] = 'OP_BOOLAND';\n  OPS[(OPS['OP_BOOLOR'] = 155)] = 'OP_BOOLOR';\n  OPS[(OPS['OP_NUMEQUAL'] = 156)] = 'OP_NUMEQUAL';\n  OPS[(OPS['OP_NUMEQUALVERIFY'] = 157)] = 'OP_NUMEQUALVERIFY';\n  OPS[(OPS['OP_NUMNOTEQUAL'] = 158)] = 'OP_NUMNOTEQUAL';\n  OPS[(OPS['OP_LESSTHAN'] = 159)] = 'OP_LESSTHAN';\n  OPS[(OPS['OP_GREATERTHAN'] = 160)] = 'OP_GREATERTHAN';\n  OPS[(OPS['OP_LESSTHANOREQUAL'] = 161)] = 'OP_LESSTHANOREQUAL';\n  OPS[(OPS['OP_GREATERTHANOREQUAL'] = 162)] = 'OP_GREATERTHANOREQUAL';\n  OPS[(OPS['OP_MIN'] = 163)] = 'OP_MIN';\n  OPS[(OPS['OP_MAX'] = 164)] = 'OP_MAX';\n  OPS[(OPS['OP_WITHIN'] = 165)] = 'OP_WITHIN';\n  OPS[(OPS['OP_RIPEMD160'] = 166)] = 'OP_RIPEMD160';\n  OPS[(OPS['OP_SHA1'] = 167)] = 'OP_SHA1';\n  OPS[(OPS['OP_SHA256'] = 168)] = 'OP_SHA256';\n  OPS[(OPS['OP_HASH160'] = 169)] = 'OP_HASH160';\n  OPS[(OPS['OP_HASH256'] = 170)] = 'OP_HASH256';\n  OPS[(OPS['OP_CODESEPARATOR'] = 171)] = 'OP_CODESEPARATOR';\n  OPS[(OPS['OP_CHECKSIG'] = 172)] = 'OP_CHECKSIG';\n  OPS[(OPS['OP_CHECKSIGVERIFY'] = 173)] = 'OP_CHECKSIGVERIFY';\n  OPS[(OPS['OP_CHECKMULTISIG'] = 174)] = 'OP_CHECKMULTISIG';\n  OPS[(OPS['OP_CHECKMULTISIGVERIFY'] = 175)] = 'OP_CHECKMULTISIGVERIFY';\n  OPS[(OPS['OP_NOP1'] = 176)] = 'OP_NOP1';\n  OPS[(OPS['OP_CHECKLOCKTIMEVERIFY'] = 177)] = 'OP_CHECKLOCKTIMEVERIFY';\n  OPS[(OPS['OP_NOP2'] = 177)] = 'OP_NOP2';\n  OPS[(OPS['OP_CHECKSEQUENCEVERIFY'] = 178)] = 'OP_CHECKSEQUENCEVERIFY';\n  OPS[(OPS['OP_NOP3'] = 178)] = 'OP_NOP3';\n  OPS[(OPS['OP_NOP4'] = 179)] = 'OP_NOP4';\n  OPS[(OPS['OP_NOP5'] = 180)] = 'OP_NOP5';\n  OPS[(OPS['OP_NOP6'] = 181)] = 'OP_NOP6';\n  OPS[(OPS['OP_NOP7'] = 182)] = 'OP_NOP7';\n  OPS[(OPS['OP_NOP8'] = 183)] = 'OP_NOP8';\n  OPS[(OPS['OP_NOP9'] = 184)] = 'OP_NOP9';\n  OPS[(OPS['OP_NOP10'] = 185)] = 'OP_NOP10';\n  OPS[(OPS['OP_CHECKSIGADD'] = 186)] = 'OP_CHECKSIGADD';\n  OPS[(OPS['OP_PUBKEYHASH'] = 253)] = 'OP_PUBKEYHASH';\n  OPS[(OPS['OP_PUBKEY'] = 254)] = 'OP_PUBKEY';\n  OPS[(OPS['OP_INVALIDOPCODE'] = 255)] = 'OP_INVALIDOPCODE';\n})(OPS || (OPS = {}));\n// Export modules\nexport { OPS };\n", "const HEX_STRINGS = \"0123456789abcdefABCDEF\";\nconst HEX_CODES = HEX_STRINGS.split(\"\").map((c) => c.codePointAt(0));\nconst HEX_CODEPOINTS = Array(256)\n    .fill(true)\n    .map((_, i) => {\n    const s = String.fromCodePoint(i);\n    const index = HEX_STRINGS.indexOf(s);\n    // ABCDEF will use 10 - 15\n    return index < 0 ? undefined : index < 16 ? index : index - 6;\n});\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder();\nexport function toUtf8(bytes) {\n    return DECODER.decode(bytes);\n}\nexport function fromUtf8(s) {\n    return ENCODER.encode(s);\n}\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((a, b) => a + b.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n// There are two implementations.\n// One optimizes for length of the bytes, and uses TextDecoder.\n// One optimizes for iteration count, and appends strings.\n// This removes the overhead of TextDecoder.\nexport function toHex(bytes) {\n    const b = bytes || new Uint8Array();\n    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);\n}\nfunction _toHexIterPerf(bytes) {\n    let s = \"\";\n    for (let i = 0; i < bytes.length; ++i) {\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];\n    }\n    return s;\n}\nfunction _toHexLengthPerf(bytes) {\n    const hexBytes = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; ++i) {\n        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];\n        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];\n    }\n    return DECODER.decode(hexBytes);\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const hexBytes = ENCODER.encode(hexString || \"\");\n    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));\n    let i;\n    for (i = 0; i < resultBytes.length; i++) {\n        const a = HEX_CODEPOINTS[hexBytes[i * 2]];\n        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        resultBytes[i] = (a << 4) | b;\n    }\n    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);\n}\nexport function toBase64(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nexport function fromBase64(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n// Same behavior as Buffer.compare()\nexport function compare(v1, v2) {\n    const minLength = Math.min(v1.length, v2.length);\n    for (let i = 0; i < minLength; ++i) {\n        if (v1[i] !== v2[i]) {\n            return v1[i] < v2[i] ? -1 : 1;\n        }\n    }\n    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;\n}\nexport function writeUInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0xff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);\n    }\n    buffer[offset] = value;\n    return offset + 1;\n}\nexport function writeUInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 8) & 0xff;\n        buffer[offset + 1] = value & 0xff;\n    }\n    return offset + 2;\n}\nexport function writeUInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n        buffer[offset + 2] = (value >> 16) & 0xff;\n        buffer[offset + 3] = (value >> 24) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 24) & 0xff;\n        buffer[offset + 1] = (value >> 16) & 0xff;\n        buffer[offset + 2] = (value >> 8) & 0xff;\n        buffer[offset + 3] = value & 0xff;\n    }\n    return offset + 4;\n}\nexport function writeUInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffffffffffffn) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n    return offset + 8;\n}\nexport function readUInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    return buffer[offset];\n}\nexport function readUInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = (num << 8) + buffer[offset + 1];\n        num = (num << 8) + buffer[offset];\n        return num;\n    }\n    else {\n        let num = 0;\n        num = (num << 8) + buffer[offset];\n        num = (num << 8) + buffer[offset + 1];\n        return num;\n    }\n}\nexport function readUInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        return num;\n    }\n    else {\n        let num = 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        return num;\n    }\n}\nexport function readUInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset]);\n        return num;\n    }\n    else {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        return num;\n    }\n}\nexport function writeInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0x7f || value < -0x80) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= ${-0x80} and <= ${0x7f}. Received ${value}`);\n    }\n    buffer[offset] = value;\n    return offset + 1;\n}\nexport function writeInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0x7fff || value < -0x8000) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= ${-0x8000} and <= ${0x7fff}. Received ${value}`);\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 8) & 0xff;\n        buffer[offset + 1] = value & 0xff;\n    }\n    return offset + 2;\n}\nexport function writeInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0x7fffffff || value < -0x80000000) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= ${-0x80000000} and <= ${0x7fffffff}. Received ${value}`);\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n        buffer[offset + 2] = (value >> 16) & 0xff;\n        buffer[offset + 3] = (value >> 24) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 24) & 0xff;\n        buffer[offset + 1] = (value >> 16) & 0xff;\n        buffer[offset + 2] = (value >> 8) & 0xff;\n        buffer[offset + 3] = value & 0xff;\n    }\n    return offset + 4;\n}\nexport function writeInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value}`);\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n    return offset + 8;\n}\nexport function readInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    const val = buffer[offset];\n    if (val <= 0x7f) {\n        return val;\n    }\n    else {\n        return val - 0x100;\n    }\n}\nexport function readInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        const val = buffer[offset] + (buffer[offset + 1] << 8);\n        return buffer[offset + 1] <= 0x7f ? val : val - 0x10000;\n    }\n    else {\n        const val = (buffer[offset] << 8) + buffer[offset + 1];\n        return buffer[offset] <= 0x7f ? val : val - 0x10000;\n    }\n}\nexport function readInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        const val = buffer[offset] +\n            (buffer[offset + 1] << 8) +\n            (buffer[offset + 2] << 16) +\n            ((buffer[offset + 3] << 24) >>> 0);\n        return buffer[offset + 3] <= 0x7f ? val : val - 0x100000000;\n    }\n    else {\n        const val = ((buffer[offset] << 24) >>> 0) +\n            (buffer[offset + 1] << 16) +\n            (buffer[offset + 2] << 8) +\n            buffer[offset + 3];\n        return buffer[offset] <= 0x7f ? val : val - 0x100000000;\n    }\n}\nexport function readInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    let num = 0n;\n    if (littleEndian === \"LE\") {\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset]);\n        return buffer[offset + 7] <= 0x7f ? num : num - 0x10000000000000000n;\n    }\n    else {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        return buffer[offset] <= 0x7f ? num : num - 0x10000000000000000n;\n    }\n}\n", "import { OPS } from './ops.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nexport function encodingLength(i) {\n  return i < OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nexport function encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    tools.writeUInt8(buffer, offset, num);\n    // 8 bit\n  } else if (size === 2) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA1);\n    tools.writeUInt8(buffer, offset + 1, num);\n    // 16 bit\n  } else if (size === 3) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA2);\n    tools.writeUInt16(buffer, offset + 1, num, 'LE');\n    // 32 bit\n  } else {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA4);\n    tools.writeUInt32(buffer, offset + 1, num, 'LE');\n  }\n  return size;\n}\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nexport function decode(buffer, offset) {\n  const opcode = tools.readUInt8(buffer, offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = tools.readUInt8(buffer, offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = tools.readUInt16(buffer, offset + 1, 'LE');\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = tools.readUInt32(buffer, offset + 1, 'LE');\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\n", "import * as tools from 'uint8array-tools';\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nexport function decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = tools.readUInt32(buffer, 0, 'LE');\n    const b = tools.readUInt8(buffer, 4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n      ? 4\n      : i > 0x7fff\n        ? 3\n        : i > 0x7f\n          ? 2\n          : i > 0x00\n            ? 1\n            : 0;\n}\n/**\n * Encodes a number into a Uint8Array using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Uint8Array.\n */\nexport function encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = new Uint8Array(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    tools.writeUInt8(buffer, i, value & 0xff);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    tools.writeUInt8(buffer, size - 1, negative ? 0x80 : 0x00);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\n", "import * as bip66 from './bip66.js';\nimport { isDefinedHashType } from './script.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nimport { NBufferSchemaFactory, UInt8Schema } from './types.js';\nconst ZERO = new Uint8Array(1);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return tools.concat([ZERO, x]);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = new Uint8Array(32);\n  const bstart = Math.max(0, 32 - x.length);\n  buffer.set(x, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nexport function decode(buffer) {\n  const hashType = tools.readUInt8(buffer, buffer.length - 1);\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.subarray(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = tools.concat([r, s]);\n  return { signature, hashType };\n}\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nexport function encode(signature, hashType) {\n  v.parse(\n    v.object({\n      signature: NBufferSchemaFactory(64),\n      hashType: UInt8Schema,\n    }),\n    { signature, hashType },\n  );\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = new Uint8Array(1);\n  tools.writeUInt8(hashTypeBuffer, 0, hashType);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return tools.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\n", "// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/base64/base64.ts\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      const outputDataset = schema._run(dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      const outputDataset = await schema._run(dataset, config2);\n      return outputDataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, outputDataset, config2) }\n      ) : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          // Hint: We do not distinguish between missing and `undefined` entries.\n          // The reason for this decision is that it reduces the bundle size, and\n          // we also expect that most users will expect this behavior.\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, list = []) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, list);\n    } else {\n      list.push(schema.entries[key].expects);\n    }\n  }\n  return list;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = _joinExpects(\n            _discriminators(this.key, this.options),\n            \"|\"\n          );\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = _joinExpects(\n            _discriminators(this.key, this.options),\n            \"|\"\n          );\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n", "import * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst ZERO32 = new Uint8Array(32);\nconst EC_P = tools.fromHex(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n);\nexport const NBufferSchemaFactory = size =>\n  v.pipe(v.instance(Uint8Array), v.length(size));\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nexport function stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return tools.compare(x, b[i]) === 0;\n  });\n}\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nexport function isPoint(p) {\n  if (!(p instanceof Uint8Array)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (tools.compare(ZERO32, x) === 0) return false;\n  if (tools.compare(x, EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (tools.compare(ZERO32, y) === 0) return false;\n  if (tools.compare(y, EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexport const TAPLEAF_VERSION_MASK = 0xfe;\nexport function isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!(o.output instanceof Uint8Array)) return false;\n  if (o.version !== undefined)\n    return (o.version & TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexport function isTaptree(scriptTree) {\n  if (!Array.isArray(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexport const Buffer256bitSchema = NBufferSchemaFactory(32);\nexport const Hash160bitSchema = NBufferSchemaFactory(20);\nexport const Hash256bitSchema = NBufferSchemaFactory(32);\nexport const BufferSchema = v.instance(Uint8Array);\nexport const HexSchema = v.pipe(v.string(), v.regex(/^([0-9a-f]{2})+$/i));\nexport const UInt8Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xff),\n);\nexport const UInt32Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xffffffff),\n);\nexport const SatoshiSchema = v.pipe(\n  v.bigint(),\n  v.minValue(0n),\n  v.maxValue(0x7fffffffffffffffn),\n);\nexport const NullablePartial = a =>\n  v.object(\n    Object.entries(a).reduce(\n      (acc, next) => ({ ...acc, [next[0]]: v.nullish(next[1]) }),\n      {},\n    ),\n  );\n", "export function prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexport function value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\n", "import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { stacksEqual, BufferSchema } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nexport function p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        output: BufferSchema,\n        data: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(chunk => v.is(BufferSchema, chunk)))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nexport function p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        m: v.number(),\n        n: v.number(),\n        output: BufferSchema,\n        pubkeys: v.array(v.custom(isPoint), 'Received invalid pubkey'),\n        signatures: v.array(\n          v.custom(isAcceptableSignature),\n          'Expected signature to be of type isAcceptableSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      v.parse(v.number(), chunks[0], { message: 'Output is invalid' });\n      v.parse(v.number(), chunks[chunks.length - 2], {\n        message: 'Output is invalid',\n      });\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        output: BufferSchema,\n        pubkey: v.custom(isPoint, 'invalid pubkey'),\n        signature: v.custom(\n          bscript.isCanonicalScriptSignature,\n          'Expected signature to be of type isCanonicalScriptSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!isPoint(o.pubkey)) throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && tools.compare(a.pubkey, o.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && tools.compare(a.input, o.input) !== 0)\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as tools from 'uint8array-tools';\n/**\n * Computes the HASH160 (RIPEMD-160 after SHA-256) of the given buffer.\n *\n * @param buffer - The input data to be hashed.\n * @returns The HASH160 of the input buffer.\n */\nexport function hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\n/**\n * Computes the double SHA-256 hash of the given buffer.\n *\n * @param buffer - The input data to be hashed.\n * @returns The double SHA-256 hash of the input buffer.\n */\nexport function hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexport const TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/**\n * A collection of tagged hash prefixes used in various BIP (Bitcoin Improvement Proposals)\n * and Taproot-related operations. Each prefix is represented as a `Uint8Array`.\n *\n * @constant\n * @type {TaggedHashPrefixes}\n *\n * @property {'BIP0340/challenge'} - Prefix for BIP0340 challenge.\n * @property {'BIP0340/aux'} - Prefix for BIP0340 auxiliary data.\n * @property {'BIP0340/nonce'} - Prefix for BIP0340 nonce.\n * @property {TapLeaf} - Prefix for Taproot leaf.\n * @property {TapBranch} - Prefix for Taproot branch.\n * @property {TapSighash} - Prefix for Taproot sighash.\n * @property {TapTweak} - Prefix for Taproot tweak.\n * @property {'KeyAgg list'} - Prefix for key aggregation list.\n * @property {'KeyAgg coefficient'} - Prefix for key aggregation coefficient.\n */\nexport const TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Uint8Array.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Uint8Array.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Uint8Array.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Uint8Array.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Uint8Array.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Uint8Array.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Uint8Array.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Uint8Array.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Uint8Array.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\n/**\n * Computes a tagged hash using the specified prefix and data.\n *\n * @param prefix - The prefix to use for the tagged hash. This should be one of the values from the `TaggedHashPrefix` enum.\n * @param data - The data to hash, provided as a `Uint8Array`.\n * @returns The resulting tagged hash as a `Uint8Array`.\n */\nexport function taggedHash(prefix, data) {\n  return sha256(tools.concat([TAGGED_HASH_PREFIXES[prefix], data]));\n}\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n", "/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nimport { RIPEMD160 as RIPEMD160n, ripemd160 as ripemd160n } from './legacy.ts';\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const RIPEMD160: typeof RIPEMD160n = RIPEMD160n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const ripemd160: typeof ripemd160n = ripemd160n;\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n", "import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n", "'use strict';\nimport base58 from 'bs58';\nexport default function (checksumFn) {\n    // Encode a buffer as a base58-check encoded string\n    function encode(payload) {\n        var payloadU8 = Uint8Array.from(payload);\n        var checksum = checksumFn(payloadU8);\n        var length = payloadU8.length + 4;\n        var both = new Uint8Array(length);\n        both.set(payloadU8, 0);\n        both.set(checksum.subarray(0, 4), payloadU8.length);\n        return base58.encode(both);\n    }\n    function decodeRaw(buffer) {\n        var payload = buffer.slice(0, -4);\n        var checksum = buffer.slice(-4);\n        var newChecksum = checksumFn(payload);\n        // eslint-disable-next-line\n        if (checksum[0] ^ newChecksum[0] |\n            checksum[1] ^ newChecksum[1] |\n            checksum[2] ^ newChecksum[2] |\n            checksum[3] ^ newChecksum[3])\n            return;\n        return payload;\n    }\n    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n    function decodeUnsafe(str) {\n        var buffer = base58.decodeUnsafe(str);\n        if (buffer == null)\n            return;\n        return decodeRaw(buffer);\n    }\n    function decode(str) {\n        var buffer = base58.decode(str);\n        var payload = decodeRaw(buffer);\n        if (payload == null)\n            throw new Error('Invalid checksum');\n        return payload;\n    }\n    return {\n        encode: encode,\n        decode: decode,\n        decodeUnsafe: decodeUnsafe\n    };\n}\n", "'use strict';\nimport { sha256 } from '@noble/hashes/sha256';\nimport bs58checkBase from './base.js';\n// SHA256(SHA256(buffer))\nfunction sha256x2(buffer) {\n    return sha256(sha256(buffer));\n}\nexport default bs58checkBase(sha256x2);\n", "import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isPoint,\n  Hash160bitSchema,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: Hash160bitSchema,\n        output: NBufferSchemaFactory(25),\n        pubkey: v.custom(isPoint),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, network.pubKeyHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!isPoint(chunks[1])) throw new TypeError('Input has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, chunks[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && tools.compare(a.pubkey, chunks[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, NBufferSchemaFactory, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        output: NBufferSchemaFactory(23),\n        redeem: v.partial(\n          v.object({\n            network: v.object({}),\n            output: BufferSchema,\n            input: BufferSchema,\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        input: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Uint8Array.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, o.network.scriptHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!(_redeem().output instanceof Uint8Array))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (\n          a.redeem.output &&\n          tools.compare(a.redeem.output, redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && tools.compare(a.redeem.input, redeem.input) !== 0)\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, NBufferSchemaFactory } from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(22),\n        pubkey: v.custom(isPoint, 'Not a valid pubkey'),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && tools.compare(hash, a.output.slice(2)) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, a.witness[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      // if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n      if (a.pubkey && tools.compare(a.pubkey, a.witness[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import { sha256 } from '@noble/hashes/sha256';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  Buffer256bitSchema,\n  BufferSchema,\n  isPoint,\n  NBufferSchemaFactory,\n  stacksEqual,\n  NullablePartial,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    chunk instanceof Uint8Array &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    NullablePartial({\n      network: v.object({}),\n      address: v.string(),\n      hash: Buffer256bitSchema,\n      output: NBufferSchemaFactory(34),\n      redeem: NullablePartial({\n        input: BufferSchema,\n        network: v.object({}),\n        output: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n      input: NBufferSchemaFactory(0),\n      witness: v.array(BufferSchema),\n    }),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = sha256(a.redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (\n        a.redeem &&\n        a.redeem.output &&\n        tools.compare(a.redeem.output, wScript) !== 0\n      )\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import * as tools from 'uint8array-tools';\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nexport function initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nexport function getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nconst h = hex => tools.fromHex(hex);\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(tools.compare(r.xOnlyPubkey, h(t.result)) === 0);\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n", "'use strict';\nimport * as tools from 'uint8array-tools';\nconst checkUInt64 = (n) => {\n    if (n < 0 || n > 0xffffffffffffffffn) {\n        throw new RangeError('value out of range');\n    }\n};\nfunction checkUInt53(n) {\n    if (n < 0 || n > Number.MAX_SAFE_INTEGER || n % 1 !== 0)\n        throw new RangeError('value out of range');\n}\nfunction checkUint53OrUint64(n) {\n    if (typeof n === 'number')\n        checkUInt53(n);\n    else\n        checkUInt64(n);\n}\nexport function encode(n, buffer, offset) {\n    checkUint53OrUint64(n);\n    if (offset === undefined)\n        offset = 0;\n    if (buffer === undefined) {\n        buffer = new Uint8Array(encodingLength(n));\n    }\n    let bytes = 0;\n    // 8 bit\n    if (n < 0xfd) {\n        buffer.set([Number(n)], offset);\n        bytes = 1;\n        // 16 bit\n    }\n    else if (n <= 0xffff) {\n        buffer.set([0xfd], offset);\n        tools.writeUInt16(buffer, offset + 1, Number(n), 'LE');\n        bytes = 3;\n        // 32 bit\n    }\n    else if (n <= 0xffffffff) {\n        buffer.set([0xfe], offset);\n        tools.writeUInt32(buffer, offset + 1, Number(n), 'LE');\n        bytes = 5;\n        // 64 bit\n    }\n    else {\n        buffer.set([0xff], offset);\n        tools.writeUInt64(buffer, offset + 1, BigInt(n), 'LE');\n        bytes = 9;\n    }\n    return { buffer, bytes };\n}\nexport function decode(buffer, offset) {\n    if (offset === undefined)\n        offset = 0;\n    const first = buffer.at(offset);\n    if (first === undefined)\n        throw new Error('buffer too small');\n    // 8 bit\n    if (first < 0xfd) {\n        return { numberValue: first, bigintValue: BigInt(first), bytes: 1 };\n        // 16 bit\n    }\n    else if (first === 0xfd) {\n        const val = tools.readUInt16(buffer, offset + 1, 'LE');\n        return {\n            numberValue: val,\n            bigintValue: BigInt(val),\n            bytes: 3\n        };\n        // 32 bit\n    }\n    else if (first === 0xfe) {\n        const val = tools.readUInt32(buffer, offset + 1, 'LE');\n        return {\n            numberValue: val,\n            bigintValue: BigInt(val),\n            bytes: 5\n        };\n        // 64 bit\n    }\n    else {\n        const number = tools.readUInt64(buffer, offset + 1, 'LE');\n        return { numberValue: number <= Number.MAX_SAFE_INTEGER ? Number(number) : null, bigintValue: number, bytes: 9 };\n    }\n}\nexport function encodingLength(n) {\n    checkUint53OrUint64(n);\n    return n < 0xfd ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9;\n}\n", "const HEX_STRINGS = \"0123456789abcdefABCDEF\";\nconst HEX_CODES = HEX_STRINGS.split(\"\").map((c) => c.codePointAt(0));\nconst HEX_CODEPOINTS = Array(256)\n    .fill(true)\n    .map((_, i) => {\n    const s = String.fromCodePoint(i);\n    const index = HEX_STRINGS.indexOf(s);\n    // ABCDEF will use 10 - 15\n    return index < 0 ? undefined : index < 16 ? index : index - 6;\n});\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder();\nexport function toUtf8(bytes) {\n    return DECODER.decode(bytes);\n}\nexport function fromUtf8(s) {\n    return ENCODER.encode(s);\n}\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((a, b) => a + b.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n// There are two implementations.\n// One optimizes for length of the bytes, and uses TextDecoder.\n// One optimizes for iteration count, and appends strings.\n// This removes the overhead of TextDecoder.\nexport function toHex(bytes) {\n    const b = bytes || new Uint8Array();\n    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);\n}\nfunction _toHexIterPerf(bytes) {\n    let s = \"\";\n    for (let i = 0; i < bytes.length; ++i) {\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];\n    }\n    return s;\n}\nfunction _toHexLengthPerf(bytes) {\n    const hexBytes = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; ++i) {\n        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];\n        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];\n    }\n    return DECODER.decode(hexBytes);\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const hexBytes = ENCODER.encode(hexString || \"\");\n    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));\n    let i;\n    for (i = 0; i < resultBytes.length; i++) {\n        const a = HEX_CODEPOINTS[hexBytes[i * 2]];\n        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        resultBytes[i] = (a << 4) | b;\n    }\n    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);\n}\nexport function toBase64(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nexport function fromBase64(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n// Same behavior as Buffer.compare()\nexport function compare(v1, v2) {\n    const minLength = Math.min(v1.length, v2.length);\n    for (let i = 0; i < minLength; ++i) {\n        if (v1[i] !== v2[i]) {\n            return v1[i] < v2[i] ? -1 : 1;\n        }\n    }\n    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;\n}\nexport function writeUInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0xff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);\n    }\n    buffer[offset] = value;\n}\nexport function writeUInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 8) & 0xff;\n        buffer[offset + 1] = value & 0xff;\n    }\n}\nexport function writeUInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n        buffer[offset + 2] = (value >> 16) & 0xff;\n        buffer[offset + 3] = (value >> 24) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 24) & 0xff;\n        buffer[offset + 1] = (value >> 16) & 0xff;\n        buffer[offset + 2] = (value >> 8) & 0xff;\n        buffer[offset + 3] = value & 0xff;\n    }\n}\nexport function writeUInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffffffffffffn) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\nexport function readUInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    return buffer[offset];\n}\nexport function readUInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = (num << 8) + buffer[offset + 1];\n        num = (num << 8) + buffer[offset];\n        return num;\n    }\n    else {\n        let num = 0;\n        num = (num << 8) + buffer[offset];\n        num = (num << 8) + buffer[offset + 1];\n        return num;\n    }\n}\nexport function readUInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        return num;\n    }\n    else {\n        let num = 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        return num;\n    }\n}\nexport function readUInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset]);\n        return num;\n    }\n    else {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        return num;\n    }\n}\n", "import * as types from './types.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as v from 'valibot';\nexport { varuint };\nimport * as tools from 'uint8array-tools';\nconst MAX_JS_NUMBER = 0x001fffffffffffff;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number' && typeof value !== 'bigint')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0 && value < BigInt(0))\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max && value > BigInt(max))\n    throw new Error('RangeError: value out of range');\n  if (Math.floor(Number(value)) !== Number(value))\n    throw new Error('value has a fractional component');\n}\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nexport function reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexport function cloneBuffer(buffer) {\n  const clone = new Uint8Array(buffer.length);\n  clone.set(buffer);\n  return clone;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nexport class BufferWriter {\n  buffer;\n  offset;\n  static withCapacity(size) {\n    return new BufferWriter(new Uint8Array(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  writeUInt8(i) {\n    this.offset = tools.writeUInt8(this.buffer, this.offset, i);\n  }\n  writeInt32(i) {\n    this.offset = tools.writeInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeInt64(i) {\n    this.offset = tools.writeInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeUInt32(i) {\n    this.offset = tools.writeUInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeUInt64(i) {\n    this.offset = tools.writeUInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeVarInt(i) {\n    const { bytes } = varuint.encode(i, this.buffer, this.offset);\n    this.offset += bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.buffer.set(slice, this.offset);\n    this.offset += slice.length;\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nexport class BufferReader {\n  buffer;\n  offset;\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  readUInt8() {\n    const result = tools.readUInt8(this.buffer, this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = tools.readInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = tools.readUInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readInt64() {\n    const result = tools.readInt64(this.buffer, this.offset, 'LE');\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const { bigintValue, bytes } = varuint.decode(this.buffer, this.offset);\n    this.offset += bytes;\n    return bigintValue;\n  }\n  readSlice(n) {\n    verifuint(n, MAX_JS_NUMBER);\n    const num = Number(n);\n    if (this.buffer.length < this.offset + num) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + num);\n    this.offset += num;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n", "import { getEccLib } from '../ecc_lib.js';\nimport * as bcrypto from '../crypto.js';\nimport { varuint } from '../bufferutils.js';\nimport { isTapleaf } from '../types.js';\nimport * as tools from 'uint8array-tools';\nexport const LEAF_VERSION_TAPSCRIPT = 0xc0;\nexport const MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nexport function rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (tools.compare(kj, ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nexport function toHashTree(scriptTree) {\n  if (isTapleaf(scriptTree)) return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  // hashes.sort((a, b) => a.hash.compare(b.hash));\n  hashes.sort((a, b) => tools.compare(a.hash, b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nexport function findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (tools.compare(node.hash, hash) === 0) {\n    return [];\n  }\n  return undefined;\n}\n/**\n * Calculates the tapleaf hash for a given Tapleaf object.\n * @param leaf - The Tapleaf object to calculate the hash for.\n * @returns The tapleaf hash as a Buffer.\n */\nexport function tapleafHash(leaf) {\n  const version = leaf.version || LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    tools.concat([Uint8Array.from([version]), serializeScript(leaf.output)]),\n  );\n}\n/**\n * Computes the taproot tweak hash for a given public key and optional hash.\n * If a hash is provided, the public key and hash are concatenated before computing the hash.\n * If no hash is provided, only the public key is used to compute the hash.\n *\n * @param pubKey - The public key buffer.\n * @param h - The optional hash buffer.\n * @returns The taproot tweak hash.\n */\nexport function tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    tools.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\n/**\n * Tweak a public key with a given tweak hash.\n * @param pubKey - The public key to be tweaked.\n * @param h - The tweak hash.\n * @returns The tweaked public key or null if the input is invalid.\n */\nexport function tweakKey(pubKey, h) {\n  if (!(pubKey instanceof Uint8Array)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: Uint8Array.from(res.xOnlyPubkey),\n  };\n}\n/**\n * Computes the TapBranch hash by concatenating two buffers and applying the 'TapBranch' tagged hash algorithm.\n *\n * @param a - The first buffer.\n * @param b - The second buffer.\n * @returns The TapBranch hash of the concatenated buffers.\n */\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', tools.concat([a, b]));\n}\n/**\n * Serializes a script by encoding its length as a varint and concatenating it with the script.\n *\n * @param s - The script to be serialized.\n * @returns The serialized script as a Buffer.\n */\nfunction serializeScript(s) {\n  /* global BigInt */\n  const varintLen = varuint.encodingLength(s.length);\n  const buffer = new Uint8Array(varintLen);\n  varuint.encode(s.length, buffer);\n  return tools.concat([buffer, s]);\n}\n", "import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isTaptree,\n  TAPLEAF_VERSION_MASK,\n  stacksEqual,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport { getEccLib } from '../ecc_lib.js';\nimport {\n  toHashTree,\n  rootHashFromPath,\n  findScriptPath,\n  tapleafHash,\n  tweakKey,\n  LEAF_VERSION_TAPSCRIPT,\n} from './bip341.js';\nimport * as lazy from './lazy.js';\nimport { bech32m } from 'bech32';\nimport { fromBech32 } from '../address.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nexport function p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(34),\n        internalPubkey: NBufferSchemaFactory(32),\n        hash: NBufferSchemaFactory(32), // merkle root hash, the tweak\n        pubkey: NBufferSchemaFactory(32), // tweaked with `hash` from `internalPubkey`\n        signature: v.union([\n          NBufferSchemaFactory(64),\n          NBufferSchemaFactory(65),\n        ]),\n        witness: v.array(BufferSchema),\n        scriptTree: v.custom(isTaptree, 'Taptree is not of type isTaptree'),\n        redeem: v.partial(\n          v.object({\n            output: BufferSchema, // tapleaf script\n            redeemVersion: v.number(), // tapleaf version\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        redeemVersion: v.number(),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    return fromBech32(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return toHashTree(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = tapleafHash({ output: script, version: leafVersion });\n      return rootHashFromPath(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion: witness[witness.length - 1][0] & TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = tweakKey(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = findScriptPath(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = tweakKey(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = tools.concat(\n        [\n          Uint8Array.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && tools.compare(pubkey, a.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && tools.compare(pubkey, a.output.slice(2)) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = tweakKey(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && tools.compare(pubkey, tweakedKey.x) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!getEccLib().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (tools.compare(a.hash, hashTree.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!findScriptPath(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (\n          o.redeem.output &&\n          tools.compare(a.redeem.output, o.redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !stacksEqual(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && tools.compare(a.signature, witness[0]) !== 0)\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (\n          a.internalPubkey &&\n          tools.compare(a.internalPubkey, internalPubkey) !== 0\n        )\n          throw new TypeError('Internal pubkey mismatch');\n        if (!getEccLib().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = tapleafHash({ output: script, version: leafVersion });\n        const hash = rootHashFromPath(controlBlock, leafHash);\n        const outputKey = tweakKey(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && tools.compare(pubkey, outputKey.x) !== 0)\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\n", "import * as tools from 'uint8array-tools';\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nexport function fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = tools.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\n", "import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as bscript from './script.js';\nimport { OPS as opcodes } from './script.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = new Uint8Array(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n);\nconst ONE = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n);\nconst VALUE_UINT64_MAX = tools.fromHex('ffffffffffffffff');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nexport class Transaction {\n  static DEFAULT_SEQUENCE = 0xffffffff;\n  static SIGHASH_DEFAULT = 0x00;\n  static SIGHASH_ALL = 0x01;\n  static SIGHASH_NONE = 0x02;\n  static SIGHASH_SINGLE = 0x03;\n  static SIGHASH_ANYONECANPAY = 0x80;\n  static SIGHASH_OUTPUT_MASK = 0x03;\n  static SIGHASH_INPUT_MASK = 0x80;\n  static ADVANCED_TRANSACTION_MARKER = 0x00;\n  static ADVANCED_TRANSACTION_FLAG = 0x01;\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readUInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(tools.fromHex(hex), false);\n  }\n  static isCoinbaseHash(buffer) {\n    v.parse(types.Hash256bitSchema, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  version = 1;\n  locktime = 0;\n  ins = [];\n  outs = [];\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    v.parse(\n      v.tuple([\n        types.Hash256bitSchema,\n        types.UInt32Schema,\n        v.nullable(v.optional(types.UInt32Schema)),\n        v.nullable(v.optional(types.BufferSchema)),\n      ]),\n      [hash, index, sequence, scriptSig],\n    );\n    if (sequence === undefined || sequence === null) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    v.parse(v.tuple([types.BufferSchema, types.SatoshiSchema]), [\n      scriptPubKey,\n      value,\n    ]);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, v.number()]), [\n      inIndex,\n      prevOutScript,\n      hashType,\n    ]);\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== opcodes.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = new Uint8Array(txTmp.byteLength(false) + 4);\n    tools.writeInt32(buffer, buffer.length - 4, hashType, 'LE');\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        v.array(types.BufferSchema),\n        v.array(types.SatoshiSchema),\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScripts, values, hashType],\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = BufferWriter.withCapacity(36 * this.ins.length);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(8 * this.ins.length);\n      values.forEach(value => bufferWriter.writeInt64(value));\n      hashAmounts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(4 * this.ins.length);\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      if (!this.outs.length)\n        throw new Error('Add outputs to the transaction before signing.');\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeUInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = BufferWriter.withCapacity(varSliceSize(annex));\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      tools.concat([Uint8Array.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        types.BufferSchema,\n        types.SatoshiSchema,\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScript, value, hashType],\n    );\n    let tbuffer = Uint8Array.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = new Uint8Array(36 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = new Uint8Array(4 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = new Uint8Array(txOutsSize);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = new Uint8Array(8 + varSliceSize(output.script));\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = new Uint8Array(156 + varSliceSize(prevOutScript));\n    bufferWriter = new BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return new Uint8Array(32);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return tools.toHex(reverseBuffer(this.getHash(false)));\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return tools.toHex(this.toBuffer(undefined, undefined));\n  }\n  setInputScript(index, scriptSig) {\n    v.parse(v.tuple([v.number(), types.BufferSchema]), [index, scriptSig]);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    v.parse(v.tuple([v.number(), v.array(types.BufferSchema)]), [\n      index,\n      witness,\n    ]);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = new Uint8Array(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeUInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\n", "import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { fastMerkleRoot } from './merkle.js';\nimport { Transaction } from './transaction.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nexport class Block {\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(tools.fromHex(hex));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = new Uint8Array(32);\n    target[29 - exponent] = (mantissa >> 16) & 0xff;\n    target[30 - exponent] = (mantissa >> 8) & 0xff;\n    target[31 - exponent] = mantissa & 0xff;\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    v.parse(v.array(v.object({ getHash: v.function() })), transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          tools.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  version = 1;\n  prevHash = undefined;\n  merkleRoot = undefined;\n  timestamp = 0;\n  witnessCommit = undefined;\n  bits = 0;\n  nonce = 0;\n  transactions = undefined;\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(\n        out =>\n          tools.compare(\n            out.script.slice(0, 6),\n            Uint8Array.from([0x6a, 0x24, 0xaa, 0x21, 0xa9, 0xed]),\n          ) === 0,\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Uint8Array && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Uint8Array &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return tools.toHex(reverseBuffer(this.getHash()));\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = new Uint8Array(this.byteLength(headersOnly));\n    const bufferWriter = new BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    const { bytes } = varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return tools.toHex(this.toBuffer(headersOnly));\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return tools.compare(hash, target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return tools.compare(this.merkleRoot, actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return tools.compare(this.witnessCommit, actualWitnessCommit) === 0;\n  }\n}\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n", "import { InputTypes, OutputTypes } from '../typeFields.js';\nimport * as globalXpub from './global/globalXpub.js';\nimport * as unsignedTx from './global/unsignedTx.js';\nimport * as finalScriptSig from './input/finalScriptSig.js';\nimport * as finalScriptWitness from './input/finalScriptWitness.js';\nimport * as nonWitnessUtxo from './input/nonWitnessUtxo.js';\nimport * as partialSig from './input/partialSig.js';\nimport * as porCommitment from './input/porCommitment.js';\nimport * as sighashType from './input/sighashType.js';\nimport * as tapKeySig from './input/tapKeySig.js';\nimport * as tapLeafScript from './input/tapLeafScript.js';\nimport * as tapMerkleRoot from './input/tapMerkleRoot.js';\nimport * as tapScriptSig from './input/tapScriptSig.js';\nimport * as witnessUtxo from './input/witnessUtxo.js';\nimport * as tapTree from './output/tapTree.js';\nimport * as bip32Derivation from './shared/bip32Derivation.js';\nimport * as checkPubkey from './shared/checkPubkey.js';\nimport * as redeemScript from './shared/redeemScript.js';\nimport * as tapBip32Derivation from './shared/tapBip32Derivation.js';\nimport * as tapInternalKey from './shared/tapInternalKey.js';\nimport * as witnessScript from './shared/witnessScript.js';\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(InputTypes.BIP32_DERIVATION),\n  redeemScript: redeemScript.makeConverter(InputTypes.REDEEM_SCRIPT),\n  witnessScript: witnessScript.makeConverter(InputTypes.WITNESS_SCRIPT),\n  checkPubkey: checkPubkey.makeChecker([\n    InputTypes.PARTIAL_SIG,\n    InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(InputTypes.TAP_INTERNAL_KEY),\n  tapMerkleRoot,\n};\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(OutputTypes.BIP32_DERIVATION),\n  redeemScript: redeemScript.makeConverter(OutputTypes.REDEEM_SCRIPT),\n  witnessScript: witnessScript.makeConverter(OutputTypes.WITNESS_SCRIPT),\n  checkPubkey: checkPubkey.makeChecker([OutputTypes.BIP32_DERIVATION]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(OutputTypes.TAP_INTERNAL_KEY),\n};\nexport { globals, inputs, outputs };\n", "export var GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})(GlobalTypes || (GlobalTypes = {}));\nexport const GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nexport var InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})(InputTypes || (InputTypes = {}));\nexport const INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nexport var OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})(OutputTypes || (OutputTypes = {}));\nexport const OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n", "import { GlobalTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nconst range = n => [...Array(n).keys()];\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexport function encode(data) {\n  const head = new Uint8Array([GlobalTypes.GLOBAL_XPUB]);\n  const key = tools.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = new Uint8Array(splitPath.length * 4);\n  value.set(data.masterFingerprint, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    tools.writeUInt32(value, offset, num, 'LE');\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexport const expected =\n  '{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }';\nexport function check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    epk instanceof Uint8Array &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    mfp instanceof Uint8Array &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.extendedPubkey);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.extendedPubkey, item.extendedPubkey))\n      .length === 0\n  );\n}\n", "import { GlobalTypes } from '../../typeFields.js';\nexport function encode(data) {\n  return {\n    key: new Uint8Array([GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  return {\n    key: new Uint8Array([InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexport function encode(pSig) {\n  const head = new Uint8Array([InputTypes.PARTIAL_SIG]);\n  return {\n    key: tools.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexport const expected = '{ pubkey: Uint8Array; signature: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.pubkey instanceof Uint8Array &&\n    data.signature instanceof Uint8Array &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nfunction isDerSigWithSighash(buf) {\n  if (!(buf instanceof Uint8Array) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.pubkey);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.pubkey, item.pubkey) === 0).length === 0\n  );\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return tools.toUtf8(keyVal.value);\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: tools.fromUtf8(data),\n  };\n}\nexport const expected = 'string';\nexport function check(data) {\n  return typeof data === 'string';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return Number(tools.readUInt32(keyVal.value, 0, 'LE'));\n}\nexport function encode(data) {\n  const key = Uint8Array.from([InputTypes.SIGHASH_TYPE]);\n  const value = new Uint8Array(4);\n  tools.writeUInt32(value, 0, data, 'LE');\n  return {\n    key,\n    value,\n  };\n}\nexport const expected = 'number';\nexport function check(data) {\n  return typeof data === 'number';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(value) {\n  const key = Uint8Array.from([InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return (\n    data instanceof Uint8Array && (data.length === 64 || data.length === 65)\n  );\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexport function encode(tScript) {\n  const head = Uint8Array.from([InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Uint8Array.from([tScript.leafVersion]);\n  return {\n    key: tools.concat([head, tScript.controlBlock]),\n    value: tools.concat([tScript.script, verBuf]),\n  };\n}\nexport const expected =\n  '{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.controlBlock instanceof Uint8Array &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    data.script instanceof Uint8Array\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.controlBlock);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.controlBlock, item.controlBlock) === 0)\n      .length === 0\n  );\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexport function encode(value) {\n  const key = Uint8Array.from([InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array && data.length === 32;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' + tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexport function encode(tSig) {\n  const head = Uint8Array.from([InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: tools.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexport const expected =\n  '{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.pubkey instanceof Uint8Array &&\n    data.leafHash instanceof Uint8Array &&\n    data.signature instanceof Uint8Array &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.pubkey) + tools.toHex(item.leafHash);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v =>\n        tools.compare(v.pubkey, item.pubkey) === 0 &&\n        tools.compare(v.leafHash, item.leafHash) === 0,\n    ).length === 0\n  );\n}\n", "import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nimport * as varuint from 'varuint-bitcoin';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const value = tools.readInt64(keyVal.value, 0, 'LE');\n  let _offset = 8;\n  const { numberValue: scriptLen, bytes } = varuint.decode(\n    keyVal.value,\n    _offset,\n  );\n  _offset += bytes;\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexport function encode(data) {\n  const { script, value } = data;\n  const varuintlen = varuint.encodingLength(script.length);\n  const result = new Uint8Array(8 + varuintlen + script.length);\n  tools.writeInt64(result, 0, BigInt(value), 'LE');\n  varuint.encode(script.length, result, 8);\n  result.set(script, 8 + varuintlen);\n  return {\n    key: Uint8Array.from([InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexport const expected = '{ script: Uint8Array; value: bigint; }';\nexport function check(data) {\n  return data.script instanceof Uint8Array && typeof data.value === 'bigint';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\n", "import { OutputTypes } from '../../typeFields.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== OutputTypes.TAP_TREE || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const { numberValue: scriptLen, bytes } = varuint.decode(\n      keyVal.value,\n      _offset,\n    );\n    _offset += bytes;\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexport function encode(tree) {\n  const key = Uint8Array.from([OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(BigInt(tapLeaf.script.length)).buffer,\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: tools.concat(bufs),\n  };\n}\nexport const expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }';\nexport function check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        tapLeaf.script instanceof Uint8Array,\n    )\n  );\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\n", "import * as tools from 'uint8array-tools';\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nexport function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Uint8Array.from([TYPE_BYTE]);\n    const key = tools.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = new Uint8Array(splitPath.length * 4);\n    value.set(data.masterFingerprint, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      tools.writeUInt32(value, offset, num, 'LE');\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }';\n  function check(data) {\n    return (\n      data.pubkey instanceof Uint8Array &&\n      data.masterFingerprint instanceof Uint8Array &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = tools.toHex(item.pubkey);\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return (\n      array.filter(v => tools.compare(v.pubkey, item.pubkey) === 0).length === 0\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\n", "import * as tools from 'uint8array-tools';\nexport function makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + tools.toHex(keyVal.key),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\n", "import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array;\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n", "import * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nimport * as bip32Derivation from './bip32Derivation.js';\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nexport function makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const { numberValue: nHashes, bytes: nHashesLen } = varuint.decode(\n      keyVal.value,\n    );\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32),\n    });\n    const leafHashes = new Array(Number(nHashes));\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return { ...base, leafHashes };\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = new Uint8Array(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = tools.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return { ...base, value };\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Uint8Array; ' +\n    'pubkey: Uint8Array; ' +\n    'path: string; ' +\n    'leafHashes: Uint8Array[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => leafHash instanceof Uint8Array && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\n", "import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n", "import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n", "import * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nexport const range = n => [...Array(n).keys()];\nexport function reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexport function keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Uint8Array.from([0]));\n  return tools.concat(buffers);\n}\nexport function keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = new Uint8Array(keyVarIntLen + keyLen + valVarIntLen + valLen);\n  varuint.encode(keyLen, buffer, 0);\n  buffer.set(keyVal.key, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  buffer.set(keyVal.value, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\n", "import * as convert from '../converter/index.js';\nimport { range } from '../converter/tools.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nimport { GlobalTypes, InputTypes, OutputTypes } from '../typeFields.js';\nexport function psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const { numberValue: keyLen, bytes } = varuint.decode(buffer, offset);\n    offset += bytes;\n    const key = buffer.slice(offset, offset + Number(keyLen));\n    offset += Number(keyLen);\n    return key;\n  }\n  function readUInt32BE() {\n    const num = tools.readUInt32(buffer, offset, 'BE');\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = tools.readUInt8(buffer, offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = tools.readUInt8(buffer, offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = tools.toHex(keyVal.key);\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = tools.toHex(keyVal.key);\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = tools.toHex(keyVal.key);\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexport function checkKeyBuffer(type, keyBuf, keyNum) {\n  if (tools.compare(keyBuf, Uint8Array.from([keyNum]))) {\n    throw new Error(\n      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n      `Format Error: Invalid ${type} key: ${tools.toHex(keyBuf)}`,\n    );\n  }\n}\nexport function psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, GlobalTypes.UNSIGNED_TX);\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, InputTypes.NON_WITNESS_UTXO);\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, InputTypes.WITNESS_UTXO);\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, InputTypes.SIGHASH_TYPE);\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.REDEEM_SCRIPT);\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.WITNESS_SCRIPT);\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_KEY_SIG);\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_INTERNAL_KEY);\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_MERKLE_ROOT);\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.REDEEM_SCRIPT);\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.WITNESS_SCRIPT);\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.TAP_INTERNAL_KEY);\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case OutputTypes.TAP_TREE:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.TAP_TREE);\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\n", "import * as convert from '../converter/index.js';\nimport { keyValsToBuffer } from '../converter/tools.js';\nimport * as tools from 'uint8array-tools';\nexport function psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Uint8Array.from([0])]\n      : keyVals.map(keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = new Uint8Array(5);\n  header.set([0x70, 0x73, 0x62, 0x74, 0xff], 0);\n  return tools.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nconst sortKeyVals = (a, b) => {\n  return tools.compare(a.key, b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => tools.toHex(kv.key));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(tools.toHex(keyVal.key));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nexport function psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\n", "import { psbtFromKeyVals, psbtToKeyVals } from '../parser/index.js';\nimport * as tools from 'uint8array-tools';\nexport function combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      tools.compare(otherTx.toBuffer(), selfTx.toBuffer()) !== 0\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => tools.toHex(kv.key) === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = tools.toHex(keyVal.key);\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n", "import * as converter from './converter/index.js';\nimport * as tools from 'uint8array-tools';\nexport function checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexport function checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexport function checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => tools.compare(kv.key, checkKeyVal.key) === 0)\n      .length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${tools.toHex(checkKeyVal.key)}`);\n  }\n}\nexport function getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexport function inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    // @ts-ignore\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexport const updateGlobal = updateMaker('global');\nexport const updateInput = updateMaker('input');\nexport const updateOutput = updateMaker('output');\nexport function addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  updateInput(data, input);\n}\nexport function addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  updateOutput(data, output);\n}\nexport function defaultVersionSetter(version, txBuf) {\n  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  tools.writeUInt32(txBuf, 0, version, 'LE');\n  return txBuf;\n}\nexport function defaultLocktimeSetter(locktime, txBuf) {\n  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  tools.writeUInt32(txBuf, txBuf.length - 4, locktime, 'LE');\n  return txBuf;\n}\n", "import { combine } from './combiner/index.js';\nimport { psbtFromBuffer, psbtToBuffer } from './parser/index.js';\nimport { GlobalTypes, InputTypes, OutputTypes } from './typeFields.js';\nimport {\n  addInputAttributes,\n  addOutputAttributes,\n  checkForInput,\n  checkForOutput,\n  checkHasKey,\n  getEnumLength,\n  inputCheckUncleanFinalized,\n  updateGlobal,\n  updateInput,\n  updateOutput,\n} from './utils.js';\nimport * as tools from 'uint8array-tools';\nexport class Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = tools.fromBase64(data);\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = tools.fromHex(data);\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return tools.toBase64(buffer);\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return tools.toHex(buffer);\n  }\n  toBuffer() {\n    return psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = checkForInput(this.inputs, inputIndex);\n    updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = checkForOutput(this.outputs, outputIndex);\n    updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      getEnumLength(GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = checkForInput(this.inputs, inputIndex);\n    checkHasKey(keyVal, input.unknownKeyVals, getEnumLength(InputTypes));\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = checkForOutput(this.outputs, outputIndex);\n    checkHasKey(keyVal, output.unknownKeyVals, getEnumLength(OutputTypes));\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = checkForInput(this.inputs, inputIndex);\n    inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexport { checkForInput, checkForOutput } from './utils.js';\n", "import * as varuint from 'varuint-bitcoin';\nimport * as bscript from '../script.js';\nimport { Transaction } from '../transaction.js';\nimport { hash160 } from '../crypto.js';\nimport * as payments from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Checks if a given payment factory can generate a payment script from a given script.\n * @param payment The payment factory to check.\n * @returns A function that takes a script and returns a boolean indicating whether the payment factory can generate a payment script from the script.\n */\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexport const isP2MS = isPaymentFactory(payments.p2ms);\nexport const isP2PK = isPaymentFactory(payments.p2pk);\nexport const isP2PKH = isPaymentFactory(payments.p2pkh);\nexport const isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexport const isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexport const isP2SHScript = isPaymentFactory(payments.p2sh);\nexport const isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\nexport function witnessStackToScriptWitness(witness) {\n  let buffer = new Uint8Array(0);\n  function writeSlice(slice) {\n    buffer = tools.concat([buffer, slice]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = tools.concat([buffer, new Uint8Array(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nexport function pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = hash160(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      tools.compare(pubkey, element) === 0 ||\n      tools.compare(pubkeyHash, element) === 0 ||\n      tools.compare(pubkeyXOnly, element) === 0\n    );\n  });\n}\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nexport function pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nexport function checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nexport function signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case Transaction.SIGHASH_ALL:\n      break;\n    case Transaction.SIGHASH_SINGLE:\n    case Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return (\n        item instanceof Uint8Array && bscript.isCanonicalScriptSignature(item)\n      );\n    })\n    .map(sig => ({ signature: sig }));\n}\n", "import { isTapleaf, isTaptree } from '../types.js';\nimport { Transaction } from '../transaction.js';\nimport {\n  witnessStackToScriptWitness,\n  pubkeyPositionInScript,\n  isP2TR,\n} from './psbtutils.js';\nimport {\n  tweakKey,\n  tapleafHash,\n  rootHashFromPath,\n  LEAF_VERSION_TAPSCRIPT,\n  MAX_TAPTREE_DEPTH,\n} from '../payments/bip341.js';\nimport { p2tr } from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\nimport { signatureBlocksAction } from './psbtutils.js';\n/**\n * Converts a public key to an X-only public key.\n * @param pubKey The public key to convert.\n * @returns The X-only public key.\n */\nexport const toXOnly = pubKey =>\n  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nexport function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return { finalScriptWitness: witnessStackToScriptWitness(witness) };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\n/**\n * Serializes a taproot signature.\n * @param sig The signature to serialize.\n * @param sighashType The sighash type. Optional.\n * @returns The serialized taproot signature.\n */\nexport function serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Uint8Array.from([sighashType])\n    : Uint8Array.from([]);\n  return tools.concat([sig, sighashTypeByte]);\n}\n/**\n * Checks if a PSBT input is a taproot input.\n * @param input The PSBT input to check.\n * @returns True if the input is a taproot input, false otherwise.\n */\nexport function isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && isP2TR(input.witnessUtxo.script))\n    )\n  );\n}\n/**\n * Checks if a PSBT output is a taproot output.\n * @param output The PSBT output to check.\n * @param script The script to check. Optional.\n * @returns True if the output is a taproot output, false otherwise.\n */\nexport function isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && isP2TR(script))\n    )\n  );\n}\n/**\n * Checks the taproot input fields for consistency.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nexport function checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\n/**\n * Checks the taproot output fields for consistency.\n * @param outputData The original output data.\n * @param newOutputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nexport function checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && tools.compare(script, scriptPubkey) !== 0)\n      throw new Error('Error adding output. Script or address mismatch.');\n  }\n}\n/**\n * Returns the Taproot script public key.\n *\n * @param tapInternalKey - The Taproot internal key.\n * @param tapTree - The Taproot tree (optional).\n * @returns The Taproot script public key.\n */\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = p2tr({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\n/**\n * Tweak the internal public key for a specific input.\n * @param inputIndex - The index of the input.\n * @param input - The PsbtInput object representing the input.\n * @returns The tweaked internal public key.\n * @throws Error if the tap internal key cannot be tweaked.\n */\nexport function tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey && tweakKey(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        // tapInternalKey && tapInternalKey.toString('hex')\n        tapInternalKey && tools.toHex(tapInternalKey)\n      }`,\n    );\n  return outputKey.x;\n}\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nexport function tapTreeToList(tree) {\n  if (!isTaptree(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nexport function tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\n/**\n * Checks the taproot input for signatures.\n * @param input The PSBT input to check.\n * @param action The action being performed.\n * @returns True if the input has taproot signatures, false otherwise.\n */\nexport function checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    signatureBlocksAction(sig, decodeSchnorrSignature, action),\n  );\n}\n/**\n * Decodes a Schnorr signature.\n * @param signature The signature to decode.\n * @returns The decoded Schnorr signature.\n */\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType: signature.slice(64)[0] || Transaction.SIGHASH_DEFAULT,\n  };\n}\n/**\n * Extracts taproot signatures from a PSBT input.\n * @param input The PSBT input to extract signatures from.\n * @returns An array of taproot signatures.\n */\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWitness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\n/**\n * Gets the taproot signature from the witness.\n * @param finalScriptWitness The final script witness.\n * @returns The taproot signature, or undefined if not found.\n */\nfunction getTapKeySigFromWitness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\n/**\n * Converts a binary tree to a BIP371 type list.\n * @param tree The binary tap tree.\n * @param leaves A list of tapleaves. Optional.\n * @param depth The current depth. Optional.\n * @returns A list of BIP 371 tapleaves.\n * @throws Throws an error if the taptree cannot be converted to a tapleaf list.\n */\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if (isTapleaf(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\n/**\n * Inserts the tapleaves into the taproot tree.\n * @param leaves The tapleaves to insert.\n * @returns The taproot tree.\n * @throws Throws an error if there is no room left to insert a tapleaf in the tree.\n */\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\n/**\n * Inserts a tapleaf into the taproot tree.\n * @param leaf The tapleaf to insert.\n * @param tree The taproot tree.\n * @param depth The current depth. Optional.\n * @returns The updated taproot tree.\n */\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if (isTapleaf(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\n/**\n * Checks the input fields for mixed taproot and non-taproot fields.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks the output fields for mixed taproot and non-taproot fields.\n * @param inputData The original output data.\n * @param newInputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = rootHashFromPath(tapLeaf.controlBlock, leafHash);\n  return tools.compare(rootHash, merkleRoot) === 0;\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (\n    (input.tapScriptSig || [])\n      // .filter(tss => tss.leafHash.equals(leafHash))\n      .filter(tss => tools.compare(tss.leafHash, leafHash) === 0)\n      .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n      .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n      .map(t => t.signature)\n  );\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: pubkeyPositionInScript(tss.pubkey, script),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = tapleafHash({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || tools.compare(leafHash, hash) === 0;\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tools.compare(tss.leafHash, leafHash) === 0) !==\n      undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n", "import { Psbt as PsbtBase } from 'bip174';\nimport * as varuint from 'varuint-bitcoin';\nimport { checkForInput, checkForOutput } from 'bip174';\nimport { fromOutputScript, toOutputScript } from './address.js';\nimport { cloneBuffer, reverseBuffer } from './bufferutils.js';\nimport { bitcoin as btcNetwork } from './networks.js';\nimport * as payments from './payments/index.js';\nimport { tapleafHash } from './payments/bip341.js';\nimport * as bscript from './script.js';\nimport { Transaction } from './transaction.js';\nimport {\n  toXOnly,\n  tapScriptFinalizer,\n  serializeTaprootSignature,\n  isTaprootInput,\n  checkTaprootInputFields,\n  checkTaprootOutputFields,\n  checkTaprootInputForSigs,\n} from './psbt/bip371.js';\nimport {\n  witnessStackToScriptWitness,\n  checkInputForSig,\n  pubkeyInScript,\n  isP2MS,\n  isP2PK,\n  isP2PKH,\n  isP2WPKH,\n  isP2WSHScript,\n  isP2SHScript,\n  isP2TR,\n} from './psbt/psbtutils.js';\nimport * as tools from 'uint8array-tools';\nexport { toXOnly };\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: btcNetwork,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nexport class Psbt {\n  data;\n  static fromBase64(data, opts = {}) {\n    const buffer = tools.fromBase64(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = tools.fromHex(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = PsbtBase.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  __CACHE;\n  opts;\n  constructor(opts = {}, data = new PsbtBase(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkTaprootInputFields(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = toOutputScript(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    checkTaprootOutputFields(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if (isTaprootInput(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => tools.compare(sig.pubkey, pubkey) === 0)\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && toXOnly(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(\n          h => tools.compare(h.pubkey, tapSig.pubkey) === 0,\n        );\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: toXOnly(keyPair.publicKey),\n        signature: serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return { tapKeySig: serializeTaprootSignature(sig, input.sighashType) };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: toXOnly(keyPair.publicKey),\n                signature: serializeTaprootSignature(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${tools.toHex(keyPair.publicKey)}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    checkTaprootInputFields(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    checkTaprootOutputFields(outputData, updateData, 'updateOutput');\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  tx;\n  constructor(buffer = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!(input.hash instanceof Uint8Array) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? reverseBuffer(tools.fromHex(input.hash))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !(output.script instanceof Uint8Array) ||\n      typeof output.value !== 'bigint'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(\n          pSig => tools.compare(pSig.pubkey, pubkey) === 0,\n        );\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (tools.compare(root.fingerprint, d.masterFingerprint)) return false;\n    if (tools.compare(root.derivePath(d.path).publicKey, d.pubkey))\n      return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = isTaprootInput(input)\n      ? checkTaprootInputForSigs(input, action)\n      : checkInputForSig(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${tools.toHex(pubkey)}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    tools.toHex(reverseBuffer(Uint8Array.from(input.hash))) + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (tools.compare(scriptPubKey, redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (tools.compare(prevoutHash, utxoHash) !== 0) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${tools.toHex(meaningfulScript)}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(publicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, publicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return isP2TR(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Uint8Array.from([]);\n    if (tools.compare(toXOnly(pubkey), outputKey) === 0) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => pubkeyInScript(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = tapleafHash({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf =>\n        !tapLeafHashToSign ||\n        tools.compare(tapLeafHashToSign, tapLeaf.hash) === 0,\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (tools.compare(bipDv.masterFingerprint, hdKeyPair.fingerprint) === 0) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (tools.compare(bipDv.pubkey, node.publicKey) !== 0) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return tools.compare(ps.pubkey, pk) === 0;\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(vi.bigintValue);\n    return vi.numberValue;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0n;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(Number(fee / BigInt(bytes)));\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !(lastItem instanceof Uint8Array) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n        ? 'p2sh'\n        : isP2WSH\n          ? 'p2wsh'\n          : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"],
  "mappings": "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",
  "names": ["ALPHABET", "value", "encode", "split", "decode", "number", "signature", "OPS", "array", "value", "value", "num", "encode", "decode", "decode", "encode", "decode", "length", "encode", "value", "decode", "encode", "expected", "check2", "decode", "signature", "encode", "value", "encode", "decode", "number", "object", "OPS", "OPS", "OP_INT_BASE", "decode", "OPS", "instance", "value", "isLE", "_32n", "h", "length", "K", "ripemd160", "h", "h", "sha256", "ripemd160", "sha256", "ALPHABET", "encode", "length", "decode", "string", "esm_default", "encode", "length", "esm_default", "decode", "sha256", "esm_default", "OPS", "esm_default", "OPS", "esm_default", "decompile", "OPS", "import_bech32", "OPS", "EMPTY_BUFFER", "sha256", "decompile", "decode", "encode", "encodingLength", "HEX_STRINGS", "HEX_CODES", "HEX_CODEPOINTS", "ENCODER", "DECODER", "writeUInt16", "value", "writeUInt32", "writeUInt64", "readUInt16", "readUInt32", "encode", "encodingLength", "writeUInt16", "writeUInt32", "writeUInt64", "decode", "readUInt16", "readUInt32", "number", "value", "encode", "decode", "h", "import_bech32", "OPS", "import_bech32", "esm_default", "length", "length", "EMPTY_BUFFER", "ZERO", "value", "base", "sha256", "base", "GlobalTypes", "InputTypes", "OutputTypes", "check", "decode", "encode", "decode", "encode", "value", "check", "array", "encode", "encode", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAdd", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAdd", "canAdd", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAdd", "canAddToArray", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAddToArray", "array", "canAdd", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAdd", "canAdd", "check", "decode", "encode", "expected", "decode", "encode", "value", "expected", "check", "canAdd", "canAdd", "check", "decode", "encode", "expected", "decode", "check", "encode", "value", "expected", "canAdd", "canAddToArray", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAddToArray", "array", "canAdd", "check", "decode", "encode", "expected", "decode", "check", "encode", "value", "expected", "canAdd", "canAddToArray", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAddToArray", "array", "canAdd", "check", "decode", "encode", "expected", "decode", "value", "encode", "encodingLength", "expected", "check", "canAdd", "canAdd", "check", "decode", "encode", "expected", "decode", "encode", "expected", "check", "canAdd", "range", "decode", "encode", "value", "expected", "check", "canAddToArray", "array", "makeConverter", "decode", "encode", "expected", "check", "canAdd", "makeConverter", "decode", "base", "encode", "encodingLength", "value", "expected", "check", "makeConverter", "decode", "encode", "value", "expected", "check", "canAdd", "makeConverter", "decode", "encode", "expected", "check", "canAdd", "makeConverter", "range", "encodingLength", "encode", "decode", "readUInt8", "value", "range", "inputs", "outputs", "inputs", "outputs", "value", "inputs", "outputs", "expected", "canAdd", "canAddToArray", "check", "encodingLength", "encode", "signature", "signature", "Psbt", "range", "h", "signature", "p2ms", "inputs", "p2wsh", "p2sh", "decode", "encodingLength"]
}
