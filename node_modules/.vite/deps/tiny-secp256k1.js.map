{
  "version": 3,
  "sources": ["../../tiny-secp256k1/node_modules/uint8array-tools/src/mjs/browser.js", "../../tiny-secp256k1/lib/validate_error.js", "../../tiny-secp256k1/lib/validate.js", "../../tiny-secp256k1/lib/wasm_loader.browser.js", "../../tiny-secp256k1/lib/index.js"],
  "sourcesContent": ["const HEX_STRINGS = \"0123456789abcdefABCDEF\";\nconst HEX_CODES = HEX_STRINGS.split(\"\").map((c) => c.codePointAt(0));\nconst HEX_CODEPOINTS = Array(256)\n    .fill(true)\n    .map((_, i) => {\n    const s = String.fromCodePoint(i);\n    const index = HEX_STRINGS.indexOf(s);\n    // ABCDEF will use 10 - 15\n    return index < 0 ? undefined : index < 16 ? index : index - 6;\n});\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder(\"ascii\");\n// There are two implementations.\n// One optimizes for length of the bytes, and uses TextDecoder.\n// One optimizes for iteration count, and appends strings.\n// This removes the overhead of TextDecoder.\nexport function toHex(bytes) {\n    const b = bytes || new Uint8Array();\n    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);\n}\nfunction _toHexIterPerf(bytes) {\n    let s = \"\";\n    for (let i = 0; i < bytes.length; ++i) {\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];\n    }\n    return s;\n}\nfunction _toHexLengthPerf(bytes) {\n    const hexBytes = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; ++i) {\n        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];\n        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];\n    }\n    return DECODER.decode(hexBytes);\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const hexBytes = ENCODER.encode(hexString || \"\");\n    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));\n    let i;\n    for (i = 0; i < resultBytes.length; i++) {\n        const a = HEX_CODEPOINTS[hexBytes[i * 2]];\n        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        resultBytes[i] = (a << 4) | b;\n    }\n    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);\n}\n// Same behavior as Buffer.compare()\nexport function compare(v1, v2) {\n    const minLength = Math.min(v1.length, v2.length);\n    for (let i = 0; i < minLength; ++i) {\n        if (v1[i] !== v2[i]) {\n            return v1[i] < v2[i] ? -1 : 1;\n        }\n    }\n    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;\n}\n", "export const ERROR_BAD_PRIVATE = 0;\nexport const ERROR_BAD_POINT = 1;\nexport const ERROR_BAD_TWEAK = 2;\nexport const ERROR_BAD_HASH = 3;\nexport const ERROR_BAD_SIGNATURE = 4;\nexport const ERROR_BAD_EXTRA_DATA = 5;\nexport const ERROR_BAD_PARITY = 6;\nexport const ERROR_BAD_RECOVERY_ID = 7;\nconst ERRORS_MESSAGES = {\n    [ERROR_BAD_PRIVATE.toString()]: \"Expected Private\",\n    [ERROR_BAD_POINT.toString()]: \"Expected Point\",\n    [ERROR_BAD_TWEAK.toString()]: \"Expected Tweak\",\n    [ERROR_BAD_HASH.toString()]: \"Expected Hash\",\n    [ERROR_BAD_SIGNATURE.toString()]: \"Expected Signature\",\n    [ERROR_BAD_EXTRA_DATA.toString()]: \"Expected Extra Data (32 bytes)\",\n    [ERROR_BAD_PARITY.toString()]: \"Expected Parity (1 | 0)\",\n    [ERROR_BAD_RECOVERY_ID.toString()]: \"Bad Recovery Id\",\n};\nexport function throwError(errcode) {\n    const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;\n    throw new TypeError(message);\n}\n", "import { ERROR_BAD_PRIVATE, ERROR_BAD_POINT, ERROR_BAD_TWEAK, throwError, ERROR_BAD_HASH, ERROR_BAD_EXTRA_DATA, ERROR_BAD_SIGNATURE, ERROR_BAD_PARITY, ERROR_BAD_RECOVERY_ID, } from \"./validate_error.js\";\nexport const PRIVATE_KEY_SIZE = 32;\nexport const PUBLIC_KEY_COMPRESSED_SIZE = 33;\nexport const PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;\nexport const X_ONLY_PUBLIC_KEY_SIZE = 32;\nexport const TWEAK_SIZE = 32;\nexport const HASH_SIZE = 32;\nexport const EXTRA_DATA_SIZE = 32;\nexport const SIGNATURE_SIZE = 64;\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_N = new Uint8Array([\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,\n]);\n// Difference between field and order\nconst BN32_P_MINUS_N = new Uint8Array([\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n    196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\nfunction cmpBN32(data1, data2) {\n    for (let i = 0; i < 32; ++i) {\n        if (data1[i] !== data2[i]) {\n            return data1[i] < data2[i] ? -1 : 1;\n        }\n    }\n    return 0;\n}\nexport function isZero(x) {\n    return cmpBN32(x, BN32_ZERO) === 0;\n}\nexport function isPrivate(x) {\n    return (isUint8Array(x) &&\n        x.length === PRIVATE_KEY_SIZE &&\n        cmpBN32(x, BN32_ZERO) > 0 &&\n        cmpBN32(x, BN32_N) < 0);\n}\nexport function isPoint(p) {\n    return (isUint8Array(p) &&\n        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||\n            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE ||\n            p.length === X_ONLY_PUBLIC_KEY_SIZE));\n}\nexport function isXOnlyPoint(p) {\n    return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;\n}\nexport function isDERPoint(p) {\n    return (isUint8Array(p) &&\n        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||\n            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE));\n}\nexport function isPointCompressed(p) {\n    return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\nfunction isTweak(tweak) {\n    return (isUint8Array(tweak) &&\n        tweak.length === TWEAK_SIZE &&\n        cmpBN32(tweak, BN32_N) < 0);\n}\nfunction isHash(h) {\n    return isUint8Array(h) && h.length === HASH_SIZE;\n}\nfunction isExtraData(e) {\n    return e === undefined || (isUint8Array(e) && e.length === EXTRA_DATA_SIZE);\n}\nfunction isSignature(signature) {\n    return (isUint8Array(signature) &&\n        signature.length === 64 &&\n        cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n        cmpBN32(signature.subarray(32, 64), BN32_N) < 0);\n}\nfunction isSigrLessThanPMinusN(signature) {\n    return (isUint8Array(signature) &&\n        signature.length === 64 &&\n        cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0);\n}\nexport function validateParity(p) {\n    if (p !== 0 && p !== 1)\n        throwError(ERROR_BAD_PARITY);\n}\nexport function validatePrivate(d) {\n    if (!isPrivate(d))\n        throwError(ERROR_BAD_PRIVATE);\n}\nexport function validatePoint(p) {\n    if (!isPoint(p))\n        throwError(ERROR_BAD_POINT);\n}\nexport function validateXOnlyPoint(p) {\n    if (!isXOnlyPoint(p))\n        throwError(ERROR_BAD_POINT);\n}\nexport function validateTweak(tweak) {\n    if (!isTweak(tweak))\n        throwError(ERROR_BAD_TWEAK);\n}\nexport function validateHash(h) {\n    if (!isHash(h))\n        throwError(ERROR_BAD_HASH);\n}\nexport function validateExtraData(e) {\n    if (!isExtraData(e))\n        throwError(ERROR_BAD_EXTRA_DATA);\n}\nexport function validateSignature(signature) {\n    if (!isSignature(signature))\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSignatureCustom(validatorFn) {\n    if (!validatorFn())\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSignatureNonzeroRS(signature) {\n    if (isZero(signature.subarray(0, 32)))\n        throwError(ERROR_BAD_SIGNATURE);\n    if (isZero(signature.subarray(32, 64)))\n        throwError(ERROR_BAD_SIGNATURE);\n}\nexport function validateSigrPMinusN(signature) {\n    if (!isSigrLessThanPMinusN(signature))\n        throwError(ERROR_BAD_RECOVERY_ID);\n}\n", "// Suppress TS2792: Cannot find module './secp256k1.wasm'.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport * as wasm from \"./secp256k1.wasm\";\nexport default wasm;\n", "import { compare } from \"uint8array-tools\";\nimport * as validate from \"./validate.js\";\nimport wasm from \"./wasm_loader.js\";\nconst WASM_BUFFER = new Uint8Array(wasm.memory.buffer);\nconst WASM_PRIVATE_KEY_PTR = wasm.PRIVATE_INPUT.value;\nconst WASM_PUBLIC_KEY_INPUT_PTR = wasm.PUBLIC_KEY_INPUT.value;\nconst WASM_PUBLIC_KEY_INPUT_PTR2 = wasm.PUBLIC_KEY_INPUT2.value;\nconst WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = wasm.X_ONLY_PUBLIC_KEY_INPUT.value;\nconst WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = wasm.X_ONLY_PUBLIC_KEY_INPUT2.value;\nconst WASM_TWEAK_INPUT_PTR = wasm.TWEAK_INPUT.value;\nconst WASM_HASH_INPUT_PTR = wasm.HASH_INPUT.value;\nconst WASM_EXTRA_DATA_INPUT_PTR = wasm.EXTRA_DATA_INPUT.value;\nconst WASM_SIGNATURE_INPUT_PTR = wasm.SIGNATURE_INPUT.value;\nconst PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + validate.PRIVATE_KEY_SIZE);\nconst PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + validate.PUBLIC_KEY_UNCOMPRESSED_SIZE);\nconst PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + validate.PUBLIC_KEY_UNCOMPRESSED_SIZE);\nconst X_ONLY_PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + validate.X_ONLY_PUBLIC_KEY_SIZE);\nconst X_ONLY_PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + validate.X_ONLY_PUBLIC_KEY_SIZE);\nconst TWEAK_INPUT = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + validate.TWEAK_SIZE);\nconst HASH_INPUT = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + validate.HASH_SIZE);\nconst EXTRA_DATA_INPUT = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + validate.EXTRA_DATA_SIZE);\nconst SIGNATURE_INPUT = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + validate.SIGNATURE_SIZE);\nfunction assumeCompression(compressed, p) {\n    if (compressed === undefined) {\n        return p !== undefined ? p.length : validate.PUBLIC_KEY_COMPRESSED_SIZE;\n    }\n    return compressed\n        ? validate.PUBLIC_KEY_COMPRESSED_SIZE\n        : validate.PUBLIC_KEY_UNCOMPRESSED_SIZE;\n}\nfunction _isPoint(p) {\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        return wasm.isPoint(p.length) === 1;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function __initializeContext() {\n    wasm.initializeContext();\n}\nexport function isPoint(p) {\n    return validate.isDERPoint(p) && _isPoint(p);\n}\nexport function isPointCompressed(p) {\n    return validate.isPointCompressed(p) && _isPoint(p);\n}\nexport function isXOnlyPoint(p) {\n    return validate.isXOnlyPoint(p) && _isPoint(p);\n}\nexport function isPrivate(d) {\n    return validate.isPrivate(d);\n}\nexport function pointAdd(pA, pB, compressed) {\n    validate.validatePoint(pA);\n    validate.validatePoint(pB);\n    const outputlen = assumeCompression(compressed, pA);\n    try {\n        PUBLIC_KEY_INPUT.set(pA);\n        PUBLIC_KEY_INPUT2.set(pB);\n        return wasm.pointAdd(pA.length, pB.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        PUBLIC_KEY_INPUT2.fill(0);\n    }\n}\nexport function pointAddScalar(p, tweak, compressed) {\n    validate.validatePoint(p);\n    validate.validateTweak(tweak);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        return wasm.pointAddScalar(p.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function pointCompress(p, compressed) {\n    validate.validatePoint(p);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        wasm.pointCompress(p.length, outputlen);\n        return PUBLIC_KEY_INPUT.slice(0, outputlen);\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function pointFromScalar(d, compressed) {\n    validate.validatePrivate(d);\n    const outputlen = assumeCompression(compressed);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        return wasm.pointFromScalar(outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointFromScalar(d) {\n    validate.validatePrivate(d);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        wasm.xOnlyPointFromScalar();\n        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointFromPoint(p) {\n    validate.validatePoint(p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        wasm.xOnlyPointFromPoint(p.length);\n        return X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function pointMultiply(p, tweak, compressed) {\n    validate.validatePoint(p);\n    validate.validateTweak(tweak);\n    const outputlen = assumeCompression(compressed, p);\n    try {\n        PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        return wasm.pointMultiply(p.length, outputlen) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateAdd(d, tweak) {\n    validate.validatePrivate(d);\n    validate.validateTweak(tweak);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        TWEAK_INPUT.set(tweak);\n        return wasm.privateAdd() === 1\n            ? PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateSub(d, tweak) {\n    validate.validatePrivate(d);\n    validate.validateTweak(tweak);\n    // We can not pass zero tweak to WASM, because WASM use `secp256k1_ec_seckey_negate` for tweak negate.\n    // (zero is not valid seckey)\n    if (validate.isZero(tweak)) {\n        return new Uint8Array(d);\n    }\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        TWEAK_INPUT.set(tweak);\n        return wasm.privateSub() === 1\n            ? PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE)\n            : null;\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function privateNegate(d) {\n    validate.validatePrivate(d);\n    try {\n        PRIVATE_KEY_INPUT.set(d);\n        wasm.privateNegate();\n        return PRIVATE_KEY_INPUT.slice(0, validate.PRIVATE_KEY_SIZE);\n    }\n    finally {\n        PRIVATE_KEY_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointAddTweak(p, tweak) {\n    validate.validateXOnlyPoint(p);\n    validate.validateTweak(tweak);\n    try {\n        X_ONLY_PUBLIC_KEY_INPUT.set(p);\n        TWEAK_INPUT.set(tweak);\n        const parity = wasm.xOnlyPointAddTweak();\n        return parity !== -1\n            ? {\n                parity,\n                xOnlyPubkey: X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE),\n            }\n            : null;\n    }\n    finally {\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function xOnlyPointAddTweakCheck(point, tweak, resultToCheck, tweakParity) {\n    validate.validateXOnlyPoint(point);\n    validate.validateXOnlyPoint(resultToCheck);\n    validate.validateTweak(tweak);\n    const hasParity = tweakParity !== undefined;\n    if (hasParity)\n        validate.validateParity(tweakParity);\n    try {\n        X_ONLY_PUBLIC_KEY_INPUT.set(point);\n        X_ONLY_PUBLIC_KEY_INPUT2.set(resultToCheck);\n        TWEAK_INPUT.set(tweak);\n        if (hasParity) {\n            return wasm.xOnlyPointAddTweakCheck(tweakParity) === 1;\n        }\n        else {\n            wasm.xOnlyPointAddTweak();\n            const newKey = X_ONLY_PUBLIC_KEY_INPUT.slice(0, validate.X_ONLY_PUBLIC_KEY_SIZE);\n            return compare(newKey, resultToCheck) === 0;\n        }\n    }\n    finally {\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT2.fill(0);\n        TWEAK_INPUT.fill(0);\n    }\n}\nexport function sign(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        wasm.sign(e === undefined ? 0 : 1);\n        return SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function signRecoverable(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        const recoveryId = wasm.signRecoverable(e === undefined ? 0 : 1);\n        const signature = SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n        return {\n            signature,\n            recoveryId,\n        };\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function signSchnorr(h, d, e) {\n    validate.validateHash(h);\n    validate.validatePrivate(d);\n    validate.validateExtraData(e);\n    try {\n        HASH_INPUT.set(h);\n        PRIVATE_KEY_INPUT.set(d);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.set(e);\n        wasm.signSchnorr(e === undefined ? 0 : 1);\n        return SIGNATURE_INPUT.slice(0, validate.SIGNATURE_SIZE);\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PRIVATE_KEY_INPUT.fill(0);\n        if (e !== undefined)\n            EXTRA_DATA_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function verify(h, Q, signature, strict = false) {\n    validate.validateHash(h);\n    validate.validatePoint(Q);\n    validate.validateSignature(signature);\n    try {\n        HASH_INPUT.set(h);\n        PUBLIC_KEY_INPUT.set(Q);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\nexport function recover(h, signature, recoveryId, compressed = false) {\n    validate.validateHash(h);\n    validate.validateSignature(signature);\n    validate.validateSignatureNonzeroRS(signature);\n    if (recoveryId & 2) {\n        validate.validateSigrPMinusN(signature);\n    }\n    validate.validateSignatureCustom(() => isXOnlyPoint(signature.subarray(0, 32)));\n    const outputlen = assumeCompression(compressed);\n    try {\n        HASH_INPUT.set(h);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.recover(outputlen, recoveryId) === 1\n            ? PUBLIC_KEY_INPUT.slice(0, outputlen)\n            : null;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n        PUBLIC_KEY_INPUT.fill(0);\n    }\n}\nexport function verifySchnorr(h, Q, signature) {\n    validate.validateHash(h);\n    validate.validateXOnlyPoint(Q);\n    validate.validateSignature(signature);\n    try {\n        HASH_INPUT.set(h);\n        X_ONLY_PUBLIC_KEY_INPUT.set(Q);\n        SIGNATURE_INPUT.set(signature);\n        return wasm.verifySchnorr() === 1 ? true : false;\n    }\n    finally {\n        HASH_INPUT.fill(0);\n        X_ONLY_PUBLIC_KEY_INPUT.fill(0);\n        SIGNATURE_INPUT.fill(0);\n    }\n}\n"],
  "mappings": "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",
  "names": ["isPoint", "isPointCompressed", "isXOnlyPoint", "isPrivate"]
}
